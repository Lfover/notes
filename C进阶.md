#  C进阶

###  1.数据和整型存储

C语言没有字符串类型

所有的double和float都是有符号的

####  1.void

> 1.void不能用来定义变量，因为它的大小是不确定的，或是空
>
> 2.void* 可以用来定义变量，还可以用来赋值，说明void*本身给变量开辟了空间
>
> 3.但是void*对应的变量不能被直接解引用
>
> 4.void *非常特殊的应用，就是void *可以用来接收任意类型，常用于接收任意指针

####  2.补码反码

> 1.原码：对应数据的绝对值对应的二进制序列，特殊：有符号数
>
> 2.反码：符号位不变，其他按位取反（默认有符号负数）
>
> 3.补码：反码+1

###### 1.有无符号

无符号：原码=反码=补码

有符号正数：原码=反码=补码，最高位代表符号位，正（0），负（1）

有符号负数：最高位代表符号位，负（1），需要进行原反补转化

######  2、理解写入过程

原码，反码，补码约束的是原始数据

（1）先给变量开辟空间

（2）将数据转化成二进制，这里转化的过程与目标变量无关

（3)将数据放入空间

（4）完成

###### 3、使用他，读取他

在读取一个变量的时候，是该变量的类型，决定了我们如何看待该变量内部的二进制序列的含义，不论你如何看待二进制序列，二进制序列本身是不发生变化的，但是经过类型解释，二进制代表的含义是会发生对应的变化的，这也就是类型的意义

######  4、总结

**定义变量**，本质是开辟相应的空间

**写入数据**，本质是将数据转化成二进制序列（与目标变量无关），然后写入对应的内存

**读出数据**：本质是根据变量的类型，来解释内存里面的二进制是什么含义

**变量类型的作用**：1.开辟空间时决定开辟的大小。2.读取数据时，决定如何解释二进制

**如何读取变量**：1.先看变量的类型（确定是否有符号位）

​                            2.如果是无符号，直接转成十进制（任何你想）

​                            3.如果是有符号，先看符号位，如果符号位为0，整数，同上

​                            4.如果是有符号，先看符号位，如果符号位为1，先减1，再符号位不变，整体按位取反

####  3、数据的取值范围

![image-20211109194614750](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20211109194614750.png)

###  2.浮点型存储

#####  1.浮点数

> 1.浮点数可以被表示成标准科学计数法（二进制）
>
> 2.科学计数法也能表示成对应的十进制浮点数
>
> 所以对浮点数的存储，本质是对S,M,E的存储,同样的，对浮点数的读取，本质上是去读S,M,E，然后带入科学计数法公式，算出浮点数

![image-20211112122722049](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20211112122722049.png)

![image-20211112124718225](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20211112124718225.png)

**浮点数在内存中存储是将放进去的指数+127，读取的时候-127**

浮点数不能和0比较，因为多个数的值都是0，只能大于小于

###  3.字符指针

C语言没有字符串类型，但是C语言有字符串，为了方便使用字符串，通常用char类型的指针来指向该字符串的起始地址

* 指向一个字符串常量时，字符指针前最好+const,表示该指针指向的字符串常量不能改变，这是最基本素养

* 两个字符指针指向一个一模一样的数据，则这两个指针指向的地址都相同，但是如果两个数组里放的相同的数据，他还是两个不同的地址

* []的优先级高于*

  > 1.sizeof(数组名)，单独出现，没有带任何其他的东西，表示的是整个数组
  >
  > 2.&数组名，代表的是整个数组，数组的地址
  >
  > 3.数组名是第一个元素的地址
  >
  > **除了1，2其他数组名出现代表的都是首元素的地址**
  >
  > 4.二维数组名是二维数组的第一行

![image-20211112233411176](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20211112233411176.png)

数组类型的理解，不能只看前面的int等等，更要看[]里面标定元素个数

###  数组指针

> 1.数组指针是一种存放数组的指针（x)
>
> 2.数组指针是一种指针(对)
>
> **原因**：数组指针里存放的是数组的地址，不是数组

##### 指针数组

传参传的是二维数组时，可以用指针数组接收

> 你既可以用a[][n]传参，也可以用（*p)[n]

**数组传参必须降维，只要降维就会降维成指向数组内部类型的指针**

###  4.函数指针

代码也是有地址的

函数也是有地址的

函数本质的代码块，代码块本质是会包含多组代码的，也就决定了会包含一个地址序列，函数名（only)，代表的是代码块的起始地址

函数名和&函数名：这两个是一模一样的，这点和变量是不同的

函数指针数组的用途：转移表

###  4.指针进阶

###  回调函数

回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。

###  指针练习

第一题

```c++
   int a[5] = { 1, 2, 3, 4, 5 };
	int *ptr = (int *)(&a + 1);
	printf("%d,%d", *(a + 1), *(ptr - 1));
```

1.(a+1):a在表达式中代表的是首元素的地址，a+1指向下一个元素，即数组第二个元素的地址，再解引用，即数组第二个元素

2.*(ptr-1):&a是整个数组的地址，&a+1，是下一个数组的地址，再强转成整形指针,（ptr-1),减四个字节，指向数组a的最后一个元素的地址，再解引用，得到5

第二题

```c++
struct Test
	{
		int num;
		char *pcName;
		short SDate;
		char cha[2];
		short sBa[4];
	}*p;//20
int main()
{
	//假设p的值为0x100000
	printf("%p\n", p + 0x1);//0x100014   0x1就是1，给指针加1实际上是加上该指针指向的类型的大小
	printf("%p\n", (unsigned long)p + 0x1);//0x100001   指针p被强转成整形，不在是指针了，加上1就是1
	printf("%p\n", (unsigned int *)p + 0x1);//0x100004   被强转成整形指针，加上1就是加上指向类型的大小，即4
    return 0;
}
```

第三题

```c
int a[4]{1, 2, 3, 4};
	int *ptr1 = (int *)(&a + 1);
	int *ptr2 = (int *)((int)a + 1);
	printf("%x,%x", ptr[-1], *ptr);
```

1.ptr1 = (int  * )(&a + 1)，指向下一个数组的地址，ptr[-1]等价于*(ptr-1)

![image-20211116231213351](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20211116231213351.png)

###  字符函数和字符串函数

#### 字符串操作

#####  1.长度不受限制的字符串函数

#####  strlen

> 1.返回值为size_t类型，无符号类型
>
> 2.无符号数进行计算，结果也是无符号的，所以都是大于等于0的

```c++
#include <iostream>
#include <Windows.h>
using namespace std;

int main()
{

	const char *str1 = "abcdef";
	const char *str2 = "bbb";
	if (strlen(str2) - strlen(str1) > 0)
	{
		cout << "str2>str1";
	}
	else{
		cout << "str1>str2";
	}
	system("pause");
	return 0;
}
```

![image-20211121123104957](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20211121123104957.png)结果：

#####  strcpy

![image-20211121123329971](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20211121123329971.png)

因为是string 拷贝，所以一定要携带‘、0’

#####  strcat

> 1.字符串拼接的过程，本质也是拷贝
>
> 2.strcpy是从缓冲区起始位置开始拷贝的
>
> 3.strcat是从目标字符串的结尾（\0）开始拷贝的
>
> 4.既然都是拷贝，所以都可能存在越界问题，提供的目标缓冲区空间不足

```c++
#include <iostream>
#include <Windows.h>
using namespace std;

int main()
{
	const char *src_str = "12345";
	char dst_str[32] = "abcdef";
	strcat_s(dst_str, src_str);
	cout << dst_str;
	system("pause");
	return 0;
}
```

#####  strcmp

![image-20211121133618555](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20211121133618555.png)

> 如果前者大，返回1，后者大，返回-1，一样大返回0；

#####  2.长度受限制的字符串函数

#####  strncpy

> 不携带任何'\0'

#####  strncat

puts()不做任何格式化输出，原封不动的输出

#####  strncmp

> 三个参数



#####  strstr

> 再str1里寻找是否有子串str2,找到了就从找到位置开始，到字符串末尾

#####  strtok

> 用来切割字符串
>
> 1.函数内部使用static局部变量，来保存历史字符串的剩余子串
>
> 2.采用对分隔符进行设置为\0的策略来进行子串划分
>
> 3.strtok进行子串截取的时候，采用的策略是截取有效字符串
>
> 4.分割的时候，strtok会自动进行分隔符过滤

![image-20211121184053112](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20211121184053112.png)

系统调用startUp()函数，startUp()调用main()函数

main()函数退出，代表程序退出，return 0=>任务退出，且任务无错完成

return ！0->任务退出，但是任务出错，具体是什么原因，由该数字表示

#####  strerror

> 错误信息报告（退出码，错误码）
>
> strerror(n),可以输出n代表的错误

#### 字符操作

![image-20211121195729074](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20211121195729074.png)

> 大写字母改成小写字母，小写字母改成大写，判断是不是字母



#### 内存操作

> mem*系列的函数，叫做内存操作函数，本质是不关心类型，只关心操作的字节数，也就是说men*系列函数，操作的基本单位是字节

#####  memcpy

内存覆盖，可以hold住重叠

#####  memmove

内存覆盖，可以hole住重叠

**解决内存重叠的问题，解决方案是通过一定的判断，来进行决策，是从左向右拷贝，还是从右向左拷贝**

#####  memset

#####  memcmp



