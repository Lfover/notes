# c++进阶

# 类

面向对象

类的定义

访问限定符

封装

作用域

实例化

类的大小

## this指针 

> 能否为空
>
> 1.如果在成员函数中没有访问成员变量或者调用成员函数，则不会崩溃
>
> 2.如果在成员函数中访问成员变量或者调用成员函数，则会崩溃

### 必须在构造函数初始化列表位置进行初始化的成员

> 1.引用类型的成员函数
>
> 2.const类型的成员函数
>
> 3.A类中包含有B类的对象，并且B类只具有带有参数的构造函数（注意是全缺省的构造函数）

| 静态成员函数                                                 | 普通函数                                   |
| ------------------------------------------------------------ | ------------------------------------------ |
| 调用：对象.静态成员函数名（）；类名::静态成员函数名          | 对象。成员函数（）;                        |
| 内部没有this指针，没有隐藏的this指针                         | 有this指针                                 |
| 静态成员函数中不能访问非静态成员变量，不能访问非静态成员函数 | 可以访问静态成员函数，可以访问静态成员变量 |
| 静态成员函数不能使用const进行修饰，因为const修饰成员函数，本质在修饰this指针，而静态成员函数是没有this指针的 | 可以被const修饰                            |
| 静态成员函数默认调用约定：_cdecl                             | 默认调用约定：this_call                    |
|                                                              |                                            |
|                                                              |                                            |

构造函数/拷贝构造函数/赋值运算符重载/析构函数都不能被static修饰

# C语言动态内存管理的方式

### malloc calloc realloc相同点

> 1.都是C语言中用来进行动态内存申请的库函数
>
> 2.申请的空间都在堆上，用完之后必须要使用free来进行释放
>
> 3.如果申请空间成功，返回空间的首地址，如果申请失败返回的是NULL，因此在使用之前必须判空
>
> 4.返回值都是void*类型，在接收返回值时必须要强转

### malloc calloc realloc不同点

> 1.void* malloc(size_t size)
>
> malloc的参数时用户所申请空间的字节数，申请空间成功返回空间的首地址，如果申请失败，返回的是空，用户在及逆行接收时必须强转，在使用时必须要进行判空，使用完成后必须要借助free来进行释放
>
> 2.void* calloc(size_t num, size_t size)
>
> 参数个数不同：num表示元素个数，size表示单个元素的所占字节数
>
> 功能上唯一的不同是：calloc会将其申请的空间初始化为0
>
> void* realloc(void* p, size_t size):将p指向堆空间的大小调整到size字节
>
> 假设P指向的是oldsize，
>
> 当size <= oldsize 将p指向的空间缩小，然后返回原空间的首地址即可
>
> size > oldsize  将p指向的空间放大
>
> ​	大一点，直接在原有基础上扩大，
>
> ​	大很多，重新申请一段内存，将旧内容拷贝到新空间去，释放旧空间， 返回新空间地址

### 为什么C++需要单独的一套内存管理方式

> 在C++中，使用malloc/free在堆上申请或释放内置类型的空间没有任何问题，但是不能采用malloc从堆上申请对象的空间，因为malloc不会主动调用构造函数，因此该块空间不能称为对象，而只是与对象大小相同的一块堆空间，也不能使用free释放堆空间，因为free在释放对象空间时，不会对奥用析构函数将对象中的资源清理干净   、                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          

继承

1.继承的概念和定义

2.基类和派生类对象赋值转换

3.继承中的作用域

4.派生类的默认成员函数

5.继承与友元

6.继承与静态成员

7.复杂的零星继承及菱形继承虚拟继承

8.继承的总结和反思

9.笔试面试题





多态

多态1

多态2

 	

四种情况比编译器会自动给类生成默认的构造函数

> * A类中包含B类的对象，A类没有显示定义构造函数，B类带有无参或全缺省的构造函数
> * B类继承自A类，A类没有显示定义任何构造函数，B类带有无参或者全缺省发构造函数
> * 在虚拟继承中，编译器一定会给子类生成构造函数
> * 类中如果包含有虚函数，编译器一定会给该类生成构造函数

# 红黑树

##  性质

> 1.每个结点都有颜色：红色黑色
>
> 2.根节点一定是黑色的
>
> 3.如果一个结点是红色的，则其孩子结点一定是黑色的-----》没有连在一起的红色结点
>
> 4.对于每个结点，从该节点到其所有的后代叶结点的简单路径上，均包含相同数目的黑色节点（每条路径中黑色结点的个数是相同的
>
> 5.所有“叶子结点”都是黑色的（不是平常理解的叶子结点：度为0的结点||没有左右孩子的结点）
>
> 

为什么红黑树在经过上述的性质限制后， 可以保证：最长路径中结点的个数不会超过最短路径中结点个数的两倍

> 

迭代器本质

就是一个指针或是对指针进行的封装

vector和string两个迭代器就是原生态的指针：因为底层空间是连续的

### 如何给一个容器增加迭代器

1.必须要熟悉容器底层的数据结构

2.分析：迭代器设计成原生态指针||需要对指针进行哪些封装

3.创建一个迭代器类

> 1.构造方法
>
> 2.具有指针类似的方法：operator*() operator->()
>
> 3.要能移动：opreator++()/operator++(int) operator--()/operator--(int),注意有些容器可能没有，比如单链表
>
> 4.要能够比较：operator!=()/operator==()

4.在容器类中给迭代器类型取别名：typedef迭代器类型iterator

5.在容器类中增加begin()/end()





# 哈希表

借助哈希函数，将数据与其存储位置之间建立一一对应的关系，然后再查找时按照类似的方式进行查找

时间复杂度O（1）

对于常见的搜索方式，顺序查找，二分查找， 使用搜索树进进行查找，他们都有一个共性，需要多西比较才能将数据找到

有没有一种方法，能够不通过比较或是一次或非常少的次数就可以将数据找到

如果再存储数据时，通过某种方式，将数据与其存储结构之间建立一种一一对应的映射关系，查找时再按照该种映射方式来进行查找，就称为哈希

## 哈希碰撞（哈希冲突）

> 不同的元素，在往哈希表中存储时，通过哈希函数计算出了相同的位置，即多个元素要插在同一个位置

### 如何解决哈希冲突

> 1.哈希函数是否设计的合理，如果不合理要重新设计一款款哈希函数
>
> * 哈希函数的至于一定要在变革的范围之内
> * 哈希函数产生的哈希地址要尽可能均匀
> * 哈希函数要尽可能简单
>
> 直接定址法|除留余数法（对素数取模产生冲突的概率低）|平方取中法|折叠法 | 随机数法 | 数学分析法
>
> 2.在向哈希表中插入元素时，一旦发生冲突时必须要解决的
>
> 3.无论一个哈希函数设计的多精妙，都无法绝对的解决哈希冲突，哈希函数设计的越精妙，让发生冲突的概率降低

#### 专门处理哈希冲突的方法

闭散列

> 从发生哈希冲突的位置开始，找“下一个”空位置（没有元素的位置）
>
> * 线性探测：找下一个空位置方式一：逐个挨着依次往后进行查找
>
>   我怎么知道某个位置是否有元素
>
>   线性探测的缺点
>
>   荣誉产生数据的堆积，一旦发生哈希冲突，冲突的元素容易堆积在一起
>
>   与找下一个控制的方式有关，逐个挨着依次往后进行查找
>
>   线性探测优点
>
>   简单
>
> * 二次探测：找下一个方式二：不是探测两次
>
>   查找删除插入第一步都相同，通过哈希函数计算元素在表格中的位置，假设计算出来的位置是H0，假设是第i次探测，H(i) = H(0) + i^2
>
>   H(i + 1) - H(i) = 2*i + 1
>
>   如果越界了，不能把哈希地址放到0号位置（可能造成死循环），因为探测的次数越多，i比较大，2*i+ 1可能已经超过表格大小
>
>   越界的解决办法是让哈希地址%哈希容量
>
>   二次探测优点：解决了线性探测数据堆积的问题
>
>   缺点：如果表格中空位置比较少的情况下，需要特性的次数可能会非常多

插入，删除

删除时不能直接将EXIST修改为EMPTY，否则会导致改位置之后发生冲突的元素无法找到了

所以需要第三种状态，DELETE，表明该位置元素已经被删除了

❓那删除的位置可以插入新元素吗

如果要求哈希表元素唯一，则删除的位置不能插入新元素

如果没有要求，则可以插入新元素

随着哈希表中元素的不断增多，产生哈希冲突的概率也在不断的上升，当元素插入到一定程度，哈希冲突的概率可能会急剧上升，因此哈希表中元素是不会将表格填充满的

但是如果给哈希表太大的空间，会造成空间的浪费，

问题：哈希表元素应该插入到什么程度进行扩容

### 哈希负载因子

有效元素的个数/表格的总容量  的比率，负载因子永远都是小于1的

一般情况下：线性探测的负载因子控制在0.7，二次探测的负载因子控制在0.5~0.6

哈希表优点：查询的速度非常快O（1)

缺点：空间利用率非常低



哈希表不是可以存储任意数据类型嘛

```c++
return datta % _table.capacity();
```

data只能是整形的，如果不是整形，代码编译报错，所以我们要把data转化成整形的数据

如何将字符串转化为整形的数据

1.to_string(不行) ,stringstream (不行) ， atoi(不行)只能数字类型的字符串

2.去首字母的ASCII码作为转化的结果---》不好，如果首元素字母全部相同，全冲突

3.将字符串所有的字母的ASCII码加起来，---》不好，如果字符串中元素相同指示排列不一样 abcd,acdb

4.假设：都是小写字母---》把该字符串看成是26进制的数据，----》转化为10进制

​		缺陷：字符串可能会非常长，转换的结果可能无法用整形来显示

5.string:每一个string在其内部都有一段连续的空间 s.c_str():可以拿到该段空间的首地址--》地址就是一个整形数据

6.上网查



如果哈希桶中某个链表的元素特别多，某个链表特别长，严重影响哈希的效率，怎么解决

解决：想办法让不要大量的结点挂在一条链表中——将这些节点散列到其他链表中

只能将容量改变，对哈希表进行扩容

扩容时机：什么情况下哈希桶的性能最好，即在该临界状态再插入元素一定是会冲突的，所以，当检测到哈希桶中元素的个数与哈希表的容量相同，就扩容





开散列（拉链法，哈希桶）

将发生哈希冲突的元素以链表的方式串联起来，本质是一个链表的集合

哈希表中：没有直接存储元素，而存储的是链表首节点地址



再散列

给一个超过100G大小的log file,log中存着ip地址，设计算法找到出现次数最多的Ip地址？如何找到top Kd ip?如何直接用Linux系统命令实现

1.直接遍历 O(n^2)

2.排序

3.map/unordered_map:<ip,次数> 

数据量非常大---->将数据规模变小

考虑到分组

分组：

> 平均分组
>
> ![image-20220405084408006](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220405084408006.png)
>
> 先读取100M的数据，然后再统计每条IP地址出现的次数（<ip, 次数>)
>
> 但是IP在前100M当中出现的次数不是整个文件中IP真正出现的次数

问？：能否让同一个IP地址出现在相同的分组中

可以参考类似于哈希桶的方式来进行分组——————哈希切割

参考题目所给是内存限制

1.逐个从100G大小文件中获取IP地址

2.将IP地址转换为整形数据

3.用data模文件份数ret

4.将data保存在ret所在文件中

5.利用unordered_map来进行统计 



找top_K出现次数最多的前K个ip地址<ip, 次数>

一看到top_K就要想到优先级队列

如果是找前K个最大的元素，就建立小堆

如果是找前K个最小的元素，就建立大堆

因为小堆的堆顶元素是整个二叉树中最小的，建立好一个大小为K的堆，插入结点时，如果比堆顶元素小，直接舍弃，如果比堆顶元素大，把堆顶换掉，插入这个较大的结点，最终整个堆里就是前K个大的元素

![image-20220405093129308](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220405093129308.png)







给一个40亿个不充分的数据，给一个数据，快速检测该数据是否在该集合中？

1.直接遍历O(N) 

2.排序O(NlogN)+O(logN)

3.哈希O(1)

以上都不行，所以采用位图

1.数据存在, 用01表示，0表示不存在

> 1.将集合中所有的数据往位图中映射
>
> 2.查找

需要多少个比特位

取决于数据的区间范围[min,max]数据范围9900-9999

```c++
#pragma once

#include <vector>
#include <assert.h>
namespace bite
{
	template<size_t N>
	class bitset
	{
	public:
		bitset()
			: _bst((N >> 3) + 1)
			, _size(0)
		{}
		//将which的bit位置为1
		void set(size_t which)
		{
			assert(which < N);
			size_t i = which / 8;
			size_t j = which % 8;

			_bst[i] |= (1 << j);
			++_size;
		}
		//将which的bit位置为0
		void reset(size_t which)
		{
			assert(which < N);
			size_t i = which / 8;
			size_t j = which % 8;

			_bst[i] &= ~(1 << j);
			--_size;
		}

		bool test(size_t which)
		{
			assert(which < N);
			size_t i = which / 8;
			size_t j = which % 8;

			return 0 != _bst[i] & (1 << j);
		}
		size_t size()const
		{
			return N;
		}
		size_t count()const
		{
			return _size;
		}

	private:
		std::vector<unsigned char> _bst;
		size_t _size;
	};
}
#include <iostream>
using namespace std;
void TestMyBitSet()
{
	int array[] = { 1, 3, 7, 4, 12, 16, 19, 13, 22, 18 };
	bite::bitset<23> bs;
	for (auto e : array)
		bs.set(e);
	cout << bs.size() << endl;
	cout << bs.count() << endl;
	bs.set(15);
	cout << bs.count() << endl;
	if (bs.test(15))
	{
		cout << "1" << endl;
	}
	else
	{
		cout << "0" << endl;
	}


	bs.reset(15);
	cout << bs.count() << endl;
	if (bs.test(15))
	{
		cout << "1" << endl;
	}
	else
	{
		cout << "0" << endl;
	}
}
```



给定100亿个整数，设计算法找到只出现一次的整数

> 可能没有出现
>
> 可能出现一次
>
> 出现多次

需要两个bit位

需要的内存1G

1.将数据往位图中进行映射，每个数据对应两个比特位

计算字节：data/4

计算比特位data%4 

0--->01

1---->23

2---->45

3---->67

> 00一次都没有出现
>
> 01出现了一次
>
> 10出现了两次及以上

找出只出现一次的数据--》就堆这些字节两个两个比特位来进行检验

如果两个比特位是01，就代表该数据只出现了一次

给两个文件，分别有100亿个整数，我们只有1G内存，如何找到两个文件的交集

![image-20220405123029487](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220405123029487.png)



两个位图

1.先将A,B文件中的数据映射到两个位图X,Y中

2.将位图X和位图Y中的每个字节按位与，然后保存到X对应的字节中

3.在检测X中所有为1的比特位---》交集

布隆过滤器

![image-20220407174606294](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220407174606294.png)



布隆过滤器：数据不存在就一定不存在

数据存在，是可能存在，因为可能存在一个元素恰好和其他元素重叠了



|      |      |
| ---- | ---- |
|      |      |

















































