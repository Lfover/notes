##  Linux

## 第一节 、基础指令

### Linux下基础指令

####  1.目录命令

#####  `ls`

```
ls [选项][目录或文件]
```

**功能** ：列出改目录下的所有子目录与文件,这是最最最常用的命令了

>* -a:列出目录下所有文件，包括.开头的隐含文件
>
>* -l:列出文件的详细信息

##### `pwd`

```
pwd
```

**功能**：显示用户当前所在目录---打印出来的是绝对路径

##### `mkdir` 

```
mkdir [选项] dirname
```

**功能**：在当前目录下创建一个名为"dirname"的目录

> * -p:可以是一个路径名称，此时若路径中的某些目录尚不存在，加上这个选项后，系统将自动建立好那些尚不存在的目录，即一次可以创建多个目录

*示例：mkdir -p test*---可以递归创建多个目录

有创建自然就有删除，删除有两个指令，一个是rmdir ,一个是rm,我们可以对比学习

##### `rmdir`

```
rmdir [-p][dirName]
```

**功能**：rmdir的功能是删除空目录，只能删除空目录！

> * -p:加上这个操作，当子目录被删除以后，如果他的父目录也变成空的，就连带父目录一起删除

##### ` rm `

```
rm[-f -i -r -v][dirNmae/dir]
```

**功能**：rm命名可以同时删除文件或是目录

> * -f:使文件属性为只读，亦直接删除
> * -i:在删除前一个一个询问你要不要删除
> * -r:删除目录即其下所有文件

##### `cp`

```
cp [选项]源文件或目录  目标文件或目录
```

**功能**：用于复制文件或目录---copy嘛

如果同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则它会把前面指定的所有文件或目录复制到此目录中。若同时指定多个文件或目录，而最后的目的地并非一个已存在的目录，则会出现错误信息

>* -f:---force强行复制或目录，不论目的文件或目录是否已经存在
>* -i:---interactive覆盖文件之前询问你要不要覆盖
>* -r:递归处理，将指定目录下的文件与子目录一并处理

##### `mv`

```
mv [选项]源文件或目录 目标文件或目录
```

1.当第二个参数是文件时，mv命令是给文件重命名，此时只能有一个源文件 

2.当第二个参数是已经存在的目录时，源文件或目录参数可以有多个，mv将各参数指定的源文件均移至目标目录中

> * -f: force强制，如果目标文件已存在，不会询问而直接覆盖
> * -i: 如果目标文件已经存在时，会询问是否覆盖

##### `cd `

```
cd 目录名
```

**功能**：改变工作目录，将当前工作目录改变到指定的目录下

> * cd .. :返回上级目录
> * cd /home/lmr/linux/ :以绝对路径进入新的工作目录
> * cd ../lmr02/ :以相对路径进入新的工作目录
> * cd ~ :进入家目录

补充一点：`..`表示当前目录的上一级目录

​                  `.`表示当前目录自身

**linux下的目录结构是唯一的树形结构,目录结构不会随着磁盘分区而改变**

**tap键自动文件名补全**

💙💙💙💙💙💙💙💙💙💙💙💙💙平平无奇的分界线💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙

####  2.普通文件命令

文件的时间属性有三种：最后一次访问，最后一次修改，最后一次状态改变

##### `touch`

```
touch [选项]...文件...
```

**功能**：touch一个文件，若存在则刷新文件的时间属性，若无，则创建一个文件

> -d   使用指定的时间刷新时间属性

> -a   仅使用当前系统事件刷新访问时间

> -m  仅使用当前系统事件刷新修改时间

*示例：touch -d "2012-12-12 12:12:02" passwd*

##### `cat`

```
cat [选项][文件]
```

**功能**：打印文件信息直接显示在终端上

*示例：cat passwd*

##### `more`

```
more [选项][文件]
```

**功能**：分页显示文件内容

> 回车：向下按行滚动
>
> 空格：向下按页滚动
>
> q键：退出显示

#####  `less`

```
less [参数]文件
```

**功能**：分页显示文件内容

> * ⬇ 回车：向下按行滚动
>
> * 空格 f键：向下按页滚动
>
> * ⬆ b键：向上滚动
>
> * q键：退出显示
> * /string :向下匹配查找字符串
> * ？string：向上匹配查找字符串

##### `head`

```
head [参数]...[文件]...
```

**功能**：显示档案的开头至标准输出中，默认显示文件前10行内容

> * -n:指定显示的行数

#####  `tail`

```
tail [必要参数][选择参数][文件]
```

**功能**：用于显示指定文件末尾内容，不指定文件时，作为输出信息进行处理。默认显示文件末尾10行内容

>* -n:指定显示的行数
>* 动态一直等待文件末尾的新数据进行

💙💙💙💙💙💙💙💙💙💙💙💙💙平平无奇的分界线💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙

####  补充命令

##### `echo`

**功能**：打印字符串--将数据写入标准输入--显示器设备文件

##### `start`

**功能**：查看文件状态信息

##### 重定向

`>>`或`>`叫做重定向符号，作用是进行数据流的重定向，即文件的重新定向，将要操作的数据，不再写入原本的文件，而是写入新的文件中

*示例：echo "abcd">>text.txt*---将原本要写入标准输出文件的数据，写到text.txt文件中

> `>>`:追加重定向,将数据重新定向到指定的文件中,但是新数据会追加写入到文件末尾
>
> `>`:清空重定向,将新数据重定向到指定的文件中,但是在这之前会清空文件原有的内容

##### 管道符

`|`:head -23 ./passwd | tail -n 1

连接两个命令,将前面命令输出结果,当作后面命令的输入数据,让后面的命令进行处理

##### `ifconfig`

查看网卡信息

##### `shutdown -h now`

关机命令

##### `man`

手册查看命令

*man ls*:查看ls命令的手册

*man fopen*:查看fopen函数的手册

💙💙💙💙💙💙💙💙💙💙💙💙💙平平无奇的分界线💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙

#### 3.压缩文件命令

压缩和打包是不同的

* 压缩:将一个文件按照一些压缩算法,将文件数据从多变少

##### `zip/unzip`

```
zip/unzip 压缩文件.zip 目录或文件
```

zip格式的压缩,文件后缀名.zip

##### `gzip/gunzip`

```
gzip/gunzip 文件或目录
```

gzip格式的压缩,文件后缀名.gz

##### `bzip2/bunzip2`

```
bzip2/bunzip 文件或目录
```

bzip2格式的压缩解压缩,文件后缀名.bz2



* 打包:将多个文件合成一个文件

##### `tar`

```
tar -czvf ***.tar.gz **.txt**.txt//打包
```

```
tar -xvf ***.tar.gz//解包
```

linux下使用度最高的打包解包工具,将多个文件打包成为一个文件,提供解包功能,并且打包解包的同时可以进行压缩解压缩

> * -c:打包
> * -x:解包
> * -z:打包同时进行gzip格式的压缩解压缩
> * -j:打包解包过程同时进行bzip2格式压缩解压缩
> * -v:显示打包解包信息
> * -f:用于指定tar包名称,通常是作为最后一个选项,因为后面要跟上打包名称

💙💙💙💙💙💙💙💙💙💙💙💙💙平平无奇的分界线💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙

####  4.匹配查找命令

##### `grep`

**功能**:从文件内容中匹配包含某个字符串的行,常用于在某个文件中找函数

> * -i:匹配时忽略大小写
> * -v:反向匹配,匹配不包含指定字符串的行
> * -R:对指定目录下的文件递归逐个进行内容匹配

##### `find`

**功能**:从指定目录中查找指定名称/大小/时间/类型的文件

> * find ./ -name "\*test*" 通过文件名查找文件
>
> * find ./ -type d 通过文件类型找文件----->f:普通文件  d:目录文件   c:字符设备   b:块设备   p:管道设备  l:符号链接文件  s:套接字文件
> * find ./ -size -10M  通过文件大小找文件---->10M以内的文件   +10M时超过10M的文件
> * find ./ -mmin -10 通过文件时间找文件---->cmin/mmin/amin以分钟为单位    ctime/mtime/atime 以天为单位

💙💙💙💙💙💙💙💙💙💙💙💙💙平平无奇的分界线💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙

### shell的理解

📍为什么在终端中输入一串字符串,回车会被当做命令行,完成某个功能?

shell是操作系统内核与用户之间的桥梁---命令行解释器

用户不能直接访问系统内核----直接访问太危险

shell会捕捉用户的标准输入,得到字符串,通过字符串判断用户想要干什么

用户不能直接访问内核,操作系统提供一些接口,系统调用接口用户只通过这些接口来完成内核某个特定功能的访问

浏览目录这种功能会涉及到很多系统调用接口,为了便于用户使用,因此大佬使用又使用系统调用接口封装了一些直接完成常用功能的程序

功能程序---被称为shell命令程序

用户输入ls字符串,shell捕捉到之后,就会执行ls这个命令程序完成浏览目录的功能

📍终端为什么能够执行命令?

因为终端打开之后默认就运行了一个程序---->shell---->命令行解释程序

shell程序多种多样--->bash dash csh

我们执行命令都是一个个程序---->我们在终端中输入什么字符串,shell捕捉到之后,就会执行什么程序,完成对应功能

windows下的shell就是ui操作界面

### Linux的权限

**权限**:控制一个用户权利的东西

📍为什么要有权限

> 如果每个人都可以干任何事情,则秩序是混乱的

Linux下有两个用户:**超级用户/普通用户**

su命令进行用户切换---->目的就是为了获取这个用户的操作权限

##### 文件的权限

文件权限的操作指令：描述哪个用户可以对文件如何操作

文件访问用户的分类：文件所有者-u，文件所属组-g，其他用户-o

文件访问操作的分类：可读-r，可写-w，可执行-x

##### 权限表示

显示字符表示：rwx rwx r--

八进制数字表示：7 7 4

##### 文件访问权限指令

定义：创建一个文件的默认权限

##### `umask`

**功能**：查看或设置文件的创建权限掩码，也就是说掩码决定了一个文件的创建的默认权限

> * -S：人性化显示---->计算方法：777满权限-八进制掩码----->正规计算方法：给定权限&（~掩码）777&（~002）
> * 目录：可浏览-r,可在目录下删除创建文件-w,可进入-x

创建好的文件的权限修改

##### `chmod`

> * chmod 777 hello.txt 直接使用八进制数字进行修改
> * chmod a-x hello.txt 针对某类用户进行权限的删除或增加 `chmod [augo]+/-[rwx] filename`

文件用户信息的修改

##### `chown`

> * `chown username filename`修改文件所有者（只能使用root修改）

##### `chgrp`

> * `chgrp groupname filename`修改文件所属组

##### 文件权限的沾滞位

粘滞位是一个特殊的权限位--->主要用于设置目录粘滞位，其他用户在这个目录下创建文件，可以删除自己的文件，不能删除别人的

> * chmod +t filename

💙💙💙💙💙💙💙💙💙💙💙💙💙平平无奇的分界线💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙

## 第二节、常用工具

### 1.软件包管理工具

#### 什么是软件包

> * 在Linux下安装软件，通常的办法是下载到程序的源代码，并进行编译，得到可执行的文件
> * 但是这样太麻烦了，所以有些人把一些常用的软件提前编译好，做成了软件包
> * 软件包和软件包管理器，就类似于手机上的应用商店
> * `yum`是Linux下非常常用的包管理器

#### `yum`三班斧

##### 1.查看

> * `yum` `list`---->查看所有软件包
> * `yum` `search`---->搜索指定软件包

##### 2.安装

> * 首先要进入管理员权限 ---->`su` `root`
> * `yum` `install`---->安装软件包

##### 3.移除

> * 首先要进入管理员权限---->`su` `root`
> * `yum` `remove`----->卸载安装包

我们想查看常用工具是否已经安装，可以查看每个工具的版本信息，如果找不到就代表没有安装

例如

> * `vim` `--version`
> * `gcc` `--version`

**注意**：关于`yum`的所有操作必须保证主机网络畅通

💙💙💙💙💙💙💙💙💙💙💙💙💙平平无奇的分界线💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙

### 2.编辑器

#### `vim`

`vim`是一个命令行编辑器，其中不能使用鼠标----在命令行中实现光标的移动，文本的操作，文本的编辑

#### vim操作模式

总共有12种，常用三种：

> 1.**插入模式**：进行文本数据的编辑插入
>
> 2.**普通模式**：进行文本常见的操作-复制、剪切、粘贴、删除、撤销、返回、文本对齐、光标移动
>
> 3.**底行模式**：进行文本的保存和退出，以及文本的匹配查找替换操作

#### vim使用

##### 打开文件

`vim filename`---->打开一个已有的文件若不存在就会创建，打开后默认处于普通模式

##### 操作模式的切换

所有模式都是围绕普通模式进行切换的

> 1.普通模式--->插入模式 
>
> * 按`i`/`a`/`o`/`I`/`A`/`O`从普通模式进入插入模式
> * 按`i`进入插入模式，是从光标当前位置开始输入文件
>
> * 按`a`进入插入模式，光标后移一个字符开始插入
> * 按`o`进入插入模式，在光标下面新插入一行，在行首开始插入,
> * 按`I`进入插入模式，是从光标所在行的行首开始插入
> * 按`A`进入插入模式，从光标所在行的行尾开始插入
> * 按`O`进入插入模式，在光标所在上一行插入新行，在行首进行插入

> 2.普通模式--->底行模式 
>
> * 英文`:`，从普通模式到底行模式
> * `:q`退出
> * `:w` 保存
> * `:wq`保存并退出
> * `:q!` 不保存的强制退出

> 3.其他模式--->普通模式
>
> * 任何模式下按`ESC`键，都可以返回普通模式

##### 普通模式下的操作指令

###### 1.光标移动

> * `h`/`j`/`k`/`l`:按字符的上下移动
> * `w`/`b`：按单词的左右移动
> * `ctrl`+`f`/`b`：上下翻页
> * `gg`/`G`：首行/尾行

###### 2.文本操作

> * `yy`：将光标所在之处到字尾的字符复制到缓冲区中
> * `nyy`：复制从光标所在行往下数的n行文字
> * `dd`：删除光标所在行
> * `ndd`：删除从光标开始行往下的n行
> * `x`：删除字符
> * `dw`：删除单词
> * `p`：将缓冲区的字符粘贴到光标所在位置
> * `P`：将缓冲区的字符粘贴至光标所在上一行

在vim中没有剪切，删除就是剪切，虽然看到数据被删除了，但是也复制到剪切板上了

###### 3.其他操作

> `u`：撤销上一次操作
>
> `ctrl`+`r`：撤销的反向操作
>
> `gg=G`：全文对齐

##### `sudo `

**功能**：临时为用户操作提权，不用每次都切换到管理员用户了

但是`sudo`是需要配置的

> 1.`su` `root` 切换到管理员用户
>
> 2.`visudo` 打开`sudo`配置
>
> 3.:90 跳转到文档第90行，90 行附近
>
> 4.`yy`复制`root`这一行，p粘贴
>
> 5.将用户名从`root`变成自己的用户名称
>
> 6.`:wq`保存退出

💙💙💙💙💙💙💙💙💙💙💙💙💙平平无奇的分界线💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙

### 3.编译器

#### `gcc/g++`

`gcc`是C语言编译器，`g++`是c++语言编译器，不同的语言有不同的编译器

#### 编译器作用

C语言，C++语言都是高级语言，机器无法识别这些代码，需要编译器，将高级语言代码解释成为机器指令，生成可执行程序文件再能执行

可执行程序文件：一段功能的机器指令集

**编译型语言**：c/c++   

> 程序编译后才可以执行 ，运行性能高，编码较慢

**脚本型语言** ：python/lua/shell  

> 编写完毕直接执行  逐行解释型语言，由解释工具逐行解释，然后执行功能，编码较快，但运行性能低

#### 编译过程

##### 1.预处理

```
gcc  -E a.c -o a.i
```

```
gcc  -E b.c -o b.i
```

> 展开所有代码（引入头文件，宏替换，删除注释...）`gcc` `-E`（只预处理）

##### 2.编译

```
gcc -S a.i -o a.s
```

```
gcc -S b.i -o b.s
```

> 进行语义语法纠错，没有错误将代码解释成为汇编代码 `gcc` `-S`（只进行编译）

##### 3.汇编

```
gcc -c a.s -o a.o
```

```
gcc -c b.s -o b.o
```

> 将汇编代码解释成为机器指令`gcc` `-c`（只进行汇编）

##### 4.链接

```c 
gcc a.o b.o -o main
```

> 将所有用到的机器指令文件打包到一起，生成可执行程序`gcc` `-o`（指定要生成的文件名称）

📍我们在C语言中并没有定义printf函数，而且在预编译中包含的头文件中也只有函数的声明，那是哪里实现printf函数的呢？

这里引入一个重要概念

#### 函数库

![image-20220106134726937](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220106134726937.png)

图中libc是标准c库，printf就是标准c库中的函数，

**gcc编译器在链接生成可执行程序的时候，会自动链接标准c库**

###### 链接库文件的两种方式

> gcc中默认动态链接

1.**动态链接**：链接动态库，在可执行程序中记录函数符号信息表，生成的可执行程序比较小，但是运行时需要加载动态库，多个程序会在内存中使用同一个相同的库，不会再内存中造成代码冗余

2.**静态链接**：链接静态库，直接将使用的函数实现写入可执行程序中，生成的可执行程序比较大，但是运行时不需要额外依赖加载库文件，但是如果多个程序使用了相同的静态库，则运行起来会在内存中造成代码冗余

![image-20220106141213779](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220106141213779.png)

💙💙💙💙💙💙💙💙💙💙💙💙💙平平无奇的分界线💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙

### 4.调试器

#### `gdb`

* 调试一个程序的运行过程，能让我们从运行过程中发现程序哪里有问题，可以适当的改变数据达到某种调试目的

* 不是所有的程序的都可以调试，调试器只能调试具有调试符号信息的程序--->debug版本的程序

* gcc生成可执行程序，默认会生成release版本的程序，程序中没有调试符号信息，想要生成debug版本需要加上`-g`选项

  > * gcc -g a.c b.c -o mian

##### 1.调试器加载程序

> * `gdb` `./main`   直接使用gdb加载程序

##### 2.开始调试程序

> * run  直接运行
> * start   开始逐步调试

##### 3.常用调试指令

**1.流程控制**   

> * `next`/`n`：下一步，遇到函数直接运行，不会跟踪进入
> * `step`/`s`：下一步，遇到函数则跟踪进入函数
> * `list`/`l`：默认查看调试行附近代码，也可指定行--->`list` `file`:`line`
> * `until`:直接运行到指定行，也可以指定文件--->·`until` `a.c` `line`
> * `continue`/`c`：继续运行，直到断点处停下

**2.断点操作**

> * `break`/`b` `指定文件` :`指定行`：给指定文件的指定行打断点
> * `break` `function`：给函数打断点
> * `info` `break`：查看断点信息
> * `watch` `变量`：给变量打断点，放变量数据改变的时候停下
> * `delete`/`d`：删除断点

**3.调用栈操作**

> * `print`/`p`：查看变量数据---->print a;  `print` `a`=10---->设置变量数据
> * `backtrace`/`bt`：查看程序运行调用栈信息，程序一旦崩溃，查看调用栈可以快速定位崩溃位置--->栈顶函数

![image-20220106154809086](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220106154809086.png)

💙💙💙💙💙💙💙💙💙💙💙💙💙平平无奇的分界线💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙

### 5.项目自动化构建工具

#### `Makefile`/`make`

> Makefile:普通文本文件，用于记录项目的构建规则流程

> make:Makefile解释程序，逐行解释Makefile中项目的构建规则，执行构建指令，完成项目的构建

##### `Makefile`的编写规则

第一步.目标对象：依赖对象

第二步.制表符`\t` 执行指令

> **目标对象**：是要生成的可执行程序的名称

> **依赖对象**：是生成目标对象所需要的源码文件

如果你出现了和我一样，下面这张图的错误，不同担心，这代表编辑 makefile 时出现格式错误了

![image-20220106163149872](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220106163149872.png)

**记住**：第二行gcc前面需要按下`Tap`键来空出空格，其他的都无效

![image-20220106163347609](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220106163347609.png)

修改以后，就没有问题了

![image-20220106163539429](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220106163539429.png)

##### `make`的解释执行规则

1.make一旦执行，就会在当前目录寻找Makefile

2.make的执行规则中，要生成目标对象，首先要保证依赖对象已经生成，若没有生成，则会递归向下寻找依赖对象的生成规则

![image-20220106173228043](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220106173228043.png)

3.在Makefile中找到第一个目标对象，根据依赖对象的时间关系，判断是否需要重新生成

> * 生成第一个对象后，make就会退出，不会继续生成第二个对象
>
> * 📍如果非要生成两个对象呢？
>
> * > 也可以
>
>   ![image-20220106170900645](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220106170900645.png)
>
>   方法如上图，结果如下图
>
>   ![image-20220106171024069](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220106171024069.png)

4.若是需要重新生成，则执行对应下方的指令（指令不是非要生成对象的指令，也可以是打印等）

##### `make`的编写执行规则进阶版

make 中的预定义变量

> * $@：表示目标对象
> * $^：表示所有依赖对象
> * $<：表示所有依赖对象中第一个依赖对象
>
> ![image-20220106173523309](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220106173523309.png)
>
> 这样是不是还有点麻烦，通配符%的使用
>
> ![image-20220106174238344](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220106174238344.png)
>
> 简洁多了~

##### 伪对象的声明使用

```c++
.PHONY：目标对象的名称
```

**作用**：不管对象是否最新，每次都要重新生成

![image-20220106180938871](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220106180938871.png)

💙💙💙💙💙💙💙💙💙💙💙💙💙平平无奇的分界线💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙

### 6.项目版本管理工具

#### `git`

`git`:项目的版本管理工具

> 版本管理工具：对项目的开发周期进行管理，每一次提交的修改都会有对应的版本号，能够让我们在程序的时候回滚回去

##### `git`使用

1.从远程仓库克隆到本地

> git clone URL

2.本地提交修改信息

> git add ./*

3.提交本次版本管理

> git commit -m "内容"

4.将本次版本提交到远程服务器仓库

> git push origin master

**origin**用于指定分支名称

> git config --global user.name
>
> git config --global user.email

## Linux系统编程

系统编程就是学习进程的各个操作，所实现的功能，以及实现原理，流程等

### 进程概念

想要了解进程的概念,要从以下六个部分进行理解

首先,先了解什么是冯诺依曼体系结构

#### 1.冯诺依曼体系结构

##### 📍什么是冯诺依曼体系结构?

> 冯诺依曼体系结构即现代计算机的硬件体系结构：计算机应该包含五大硬件单元
>
> > 1.输入设备：采集数据
> >
> > > * 比如键盘，鼠标,扫描仪,网卡接收网络中的数据
> >
> > 2.输出设备：进行数据输出
> >
> > > * 比如显示器，打印机,网卡向网络中发送数据
> >
> > 3.存储器：进行数据中间数据缓冲
> >
> > 4.运算器：进行数据运算
> >
> > 5.控制器：进行设备管理

**运算器+控制器**就是CPU中央处理器

##### 📍图解

![image-20220108155228670](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220108155228670.png)



##### 📍所有的设备都是围绕存储器工作的

> * cpu不会直接从输入设备获取数据进行处理，而是先把数据放到存储器中，cpu从存储器中获取数据处理
> * cpu不会直接将数据交给输出设备进行输出，而是先把数据放到存储器中，控制输出设备从存储器中获取数据输出

📍既然所有的设备都是围绕着存储器工作的,那存储器是什么呢?

> * 存储器就是我们常说的内存

📍我们熟知电脑还有个叫硬盘的东西，为什么存储器是内存而不是硬盘呢?

> * 因为硬盘的吞吐量太低了,正常的机械硬盘是200MB/s
> * 内存的吞吐量是己写硬盘的数十倍

📍那内存的速度那么快,为什么内存只用于缓冲,不使用内存存储数据,而用硬盘存储呢?

> * 主要是因为硬盘与内存的存储介质是不同的
> * 内存是易失介质,数据在断电后就会丢失,而硬盘断电后数据不会丢失

接下来我们了解什么是操作系统

#### 2.操作系统

##### 📍1.什么是操作系统

> 操作系统一个“搞管理”的,（安装在计算机上的一个程序）任何一个计算机系统都包括操作系统(`os`),用来管理计算机上的软硬件资源

##### 📍2.操作系统包括啥

> * 内核
>
>   > 用来完成进程管理，内存管理，文件管理，驱动管理等
>
> * 外部应用
>
>   > 函数库，shell程序等，是为了让系统更加好用，作为系统和用户之间的桥梁

##### 📍3.为什么需要操作系统来管理

> * 用户是无法直接访问内核的，只能通过系统调用接口来访问，用户直接访问内核的`危险性`太高了
> * 为了控制风险，“听系统的话”，操作系统会向外提供访问内核的接口，这个接口就称为`系统调用接口`

##### 📍4.操作系统怎么管理

操作系统给管理方法叫：`先描述` `在组织`

###### 举例

为了更好的理解，我们引入一个例子

学校管理体系大致分为三部分：管理者，被管理者，执行者

> * 学生：自然是`被管理者`啦
>
> * 导员，老师，宿管阿姨：这些都是管学生的人，但是他们不是管理者，他们只是制度的`执行者`，真正的管理者是制度制定者
>
> * 校长：制定制度，`管理者`

###### 📌校长是怎么管理学生的呢？

假如有一个学生非常不听话，要被开除，怎么样才叫被开除呢？

* 解法一：把这个学生踢出学校，再也进不了学校的大门

> * NO

* 解法二：在这个学生后背贴上”已被退学“

> * NO

* 解法三：在这个学生的学籍档案上盖章——勒令退学

> * YES(好可怕，不要被退学~)

这样我们可以大致了解校长是怎么管理学生的----学籍档案

> 校长并不需要知道你是谁，但是他手里有你的学籍档案，你就要被”管“啦

学籍档案是什么

> 是你从上学以来的学籍信息，是一个学生的描述信息

这就是你被描述起来了

光有学籍档案就可以管理了嘛，全国有那么多学生，我要从中多的档案中找到你，得花不少时间吧

这就要谈到组织了

> 虽然学生有那么多，但是可以组织起来，分到不同的省，不同的市，不同的学校，不同的学院，不同的班级，是不是就很好找了

现在知道是怎么管理的嘛

>  从你开始上学，将你的信息收集起来，描述起来，然后放到学籍管理系统中组织起来进行管理

其实操作系统就是差不多的管理过程啦

###### 📌计算机管理硬件

> * 描述起来，例如将键盘，鼠标等用struct 结构体描述起来
> * 组织起来，利用链表或其他高效的数据结构

###### 📌流程看图解

![image-20220108155210087](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220108155210087.png)

##### 📍5.理解系统调用和库函数

> * 从开发角度看，操作系统把自己包成了一个球，但是会暴露`部分接口`，供上层开发使用，这个由操作系统提供的接口，就叫`系统调用接口`
> * 但是这个系统调用在使用上很难，他对于使用者的`要求太高`了（因为功能非常基础，用起来很费劲），所以有些开发者对部分系统调用进行了`封装`，形成了`库`，有了库以后，就极大`方便了`用户或是开发者的使用

了解完操作系统，接下来就要理解什么是进程了

#### 3.进程概念

##### 📍操作系统是怎么管理进程的呢？

> * 先把进程描述起来
> * 再把进程组织起来

我们可以看一下自己的任务管理器，它显示了我们有哪些正在运行的进程

![image-20220108153205292](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220108153205292.png)

##### 📍那什么是进程?

> * 我们课本上的概念：进程是一个程序的执行实例，正在执行的程序等
> * 内核：是担当系统分配资源的实体

🙌没听懂，有必要深入了解一下

* 一个程序运行起来，有数据和指令需要被CPU执行处理
* 根据我们所学的冯诺依曼体系结构（忘记了可以去上面复习）[点击跳转冯诺依曼](#什么是冯诺依曼体系结构?),CPU不会直接去硬盘上找程序文件进行执行处理
* 他会先将程序的数据信息加载到内存中，然后CPU从内存中获取数据以及指令进行执行处理

###### 📌操作系统中的进程都是同时运行的

> * 这个不难理解，就像我们的手机可以同时看小说、听音乐
> * 但是，我们假设只有一个cpu,是如何做到多个程序同时运行的呢？
>
> * > CPU的`分时机制`
>   >
>   > * CPU只负责执行指令，处理数据，至于处理哪一个程序，CPU并不关心
>   >
>   > * 把CPU比喻成流水线上的员工，他只负责有一个包裹过来了，就接收它，处理它，至于什么是包裹~完全不看
>   >
>   > * 那负责决定放什么包裹，什么时候放放包裹的，是谁呢？
>   >
>   > * > 是`操作系统`,操作系统对程序的运行进行调度管理
>   >
>   > * 所以CPU进行程序处理的时候不会一次性的将一个程序运行完毕才会运行下一个，而是每个程序都运行一个很短的时间，这叫`分配时间片`，时间片运行完毕，由操作系统进行调度，让另一个程序的代码数据在cpu上进行处理

###### **补充** 

###### 📌什么是调度

> * 操作系统将程序的信息放到cpu寄存器中，让cpu知道执行哪一个程序的哪一个指令，处理什么数据
> * 如果此时有多个程序运行，cpu分时机制会实现程序之间的切换
> * 如何切换，就是调度

###### 总结

* cpu分时机制实现cpu轮询处理每一个运行中的程序，而程序运行调度由操作系统进行管理

* 回到第一个问题，操作系统是怎么管理的呢 

* > 操作系统将每一个程序的运行信息保存下来，进行调度管理，所以下一次程序被分到时间片的时候才能知道这个程序上一次运行到哪里

###### 图解

![image-20220108153356132](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220108153356132.png)

> 如图，操作系统就是调度程序在1，2，3，4，5，6中来回分配时间片，时间很短，反正我们是感受不到的

###### 所以什么是进程

> * 程序的指令或数据不动，在内存中就是死的，称不上叫进程
> * 操作系统通过对一个程序进行描述，让一个程序运行起来
> * 对于操作系统来说，进程就是PCB(如上图)是一个程序运行的动态描述，通过PCB，才能实现程序运行的调度管理

`进程`--`PCB`

> 进程信息被放在一个叫做进程控制模块的数据结构中，我们称为PCB（process control block)

###### Linux下的PCB

`task_struct`

> * task_struct是Linux下的描述进程的
>
> * task_struct是Linux内核的一种数据结构，它会被装载到内存中，并且包含进程的信息

`task_struct`内容分类

> * 内存指针--->包括程序代码和进程相关数据的指针，还有其他进程共享的内存块的指针
> * 上下文数据--->进程执行时处理器的寄存器中的数据
> * 程序计数器--->程序中即将被执行的下一条指令的地址
> * 标示符--->描述本进程的唯一标识符，用来区分其他进程
> * IO状态信息--->显示的IO请求，分配给进程的IO设备，被进程使用的文件列表
> * 优先级--->相对于其他进程的优先级
> * 记账信息--->处理器时间总和，使用的时钟数总和，时间限制，记账等

**并行**：cpu资源不够的情况下，采用cpu分时机制，任务轮询处理

**并发**：多核cpu，多个进程同时占据cpu进行数据处理

#### 4.进程状态

为了弄懂正在运行的进程是什么意思，我们需要在知道进程的不同状态

Linux对进程状态进行细分

1.运行：包含正在运行以及就绪，运行态就是一个进程拿到时间片就能进行数据处理的状态

2.可中段休眠：指的是休眠可以唤醒，条件自然满足后唤醒，也可中断，被中断后置为运行态

休眠：暂时不需要cpu调度运行，让出cpu资源，休眠也有唤醒条件，会查看状态，如果是休眠，就会看唤醒条件是否满足，如果满足，则置为运行状态，进行处理，如果不满足则切换下一个进程

3.不可中断休眠：必须等到唤醒条件自然满足后才置为运行态

4.停止：停止与休眠不一样，停止只能手动唤醒

5.僵尸状态：描述一个进程退出了，但是进程资源没有完全释放，呈等待处理的一种状态

#### 5.环境变量

概念：就是一个变量，用于存储系统运行的环境参数

作用：

> * 通过修改环境变量的值，灵活配置下hi同运行环境参数（是系统环境配置更加灵活）
> * 子进程的继承性，（子进程会默认拥有父进程相同的环境变量，可以通过环境变量进行进程之间的数据传递）

命令操作

> * env
> * set
> * echo
> * export
> * unset

通过代码获得环境变量

> main函数的第三个参数
>
> * 使用extern char **environ
> * char *getenv(char *key)

代码中设置环境变量

> * setenv(char *key, char val, int override)
> * putenv(cahr *key = val)

#### 6.程序地址空间

程序地址空间，就是操作系统为进程使用mm_struct结构体描述的一个虚拟的地址空间

地址：

> 内存地址，队内存以字节为存储单位的一个编号
>
> 通过地址就能找到具体对应的内存单元

程序

> 程序就是一堆死代码，保存在程序文件中（硬盘），编译器在编译程序生成可执行文件时，就会对每一条指令，每一个数据，进行一个地址编号
>
> 当程序运行的时候，就会将指令以及数据放到指定位置的内存地址位置
>
> cpu就会根据地址偏移逐步去执行指令，以及找到对用的数据进行处理
>
> 程序运行之后才会占据内存，因此程序地址空间通常被称为进程地址空间

进程地址空间到底是什么

> * 如果真的将物理内存分成了不同的区域，代码段存放的是代码，（只读的，不能修改）
> * 如果物理内存有一段不可修改，那数据又是怎么放进去的
> * 一个内存地址只能指向一个唯一的内存单元，一个内存单元只能存储一个数据
>
> * 其实进程中所访问的地址都是虚拟地址，都是一个假地址，并非物理内存的地址
> * 我们所说的程序地址空间，实际上也是一个虚拟的地址空间
> * 是操作系统为进程通过一个mm_struct结构体所描述的一个假的地址空间
> * mm_struct (task_size, start_code, end_code)，通过大小以及区域的编号描述

原来如此

> * 原来我们所说的地址空间是一个虚拟的地址空间，只是一堆地址编号的描述（并非物理内存地址）



> * 为什么操作系统不让进程直接访问物理内存，而是弄了一个虚拟地址空间，让进程访问虚拟地址呢？

📍若进程直接访问物理内存，有什么不好？

> 1.程序在编译时，编译器就会给指令和数据进行地址编号，但是如果某个地址内存已经被占用，则程序就运行不起来了--编译器的地址管理麻烦（无法动态获知拿快内存是否被使用，也无法进行代码以及数据的地址赋值）
>
> 2.进程直接访问物理内存，如果有一个野指针，在操作的时候可能就把其他进程的数据改变了（无法进行内存访问控制）
>
> 3.程序加载通常需要使用一块连续的内存空间，内存利用率很低

通过虚拟地址空间映射到物理内存上进行数据存储，可实现数据在物理内存上的离散式存储，提高内存的利用率

并且每个进程都有自己的虚拟内存空间，因此对于每个进程来说，都会拥有自己的一块连续的空间使用

> * 虚拟地址是不具备存储能力，数据的存储依然还是要放到物理内存中段的起始位置一样，但是每个变量的偏移量不同），因此，通过段号对应的物理内存段起始地址以及虚拟地址中的偏移量组成一个完整的物理内存，找到对应的物理内存单元
> * 优点：对编译器的地址管理比较友好
> * 缺点：没有解决数据连续存储内存利用率低的问题，因为一个段管理了很多变量数据，这些变量就都从同一个起始位置进行偏移，也就在物理地址中使用了连续的地址空间（分段号式管理中，同一个段内数据都使用了连续的地址空间）每个段之间不用连续，但是段内是连续的



> * 进程中访问的都是虚拟地址，问题来了，如何通过虚拟地址找到物理内存呢？（虚拟内存和物理内存有什么关系）

##  操作系统中内存管理方式

1.分段式

> 将虚拟地址的组成分为段号+段内偏移量（比如全局数据段有很多变量，他们的段号都是一样的，也就意味着段的起始位置一样，但是每个变量的偏移量不同），因此，通过段号对应的物理内存段起始地址以及虚拟地址中的偏移量组成一个完整的物理内存，找到对应的物理内存单元
>
> > * 优点：对编译器的地址管理比较友好
> > * 缺点：没有解决数据连续存储内存利用率低的问题，因为一个段管理了很多变量数据，这些变量就都从同一个起始位置进行偏移，也就在物理地址中使用了连续的地址空间（分段号式管理中，同一个段内数据都使用了连续的地址空间）每个段之间不用连续，但是段内是连续的
>
> 

2.分页式

![image-20220113191332792](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220113191332792.png)

> 因为通常物理块比较小，并且不要求同一个进程的多个数据必须在同一块内，因此分页式实现了数据在物理内存中的离散式存储，提高了内存利用率
>
> 并且页表会在进行内存访问的时候进行内存访问控制（是否有权限）
>
> * 页表放的是页表项，每个页表项保存的都是一个虚拟内存页与对应物理内存块的映射关系
>
> * 分页式管理的优点：
>
>   >  实现数据离散式存储，提高内存利用率，并且通过页表进行内存访问控制

分页式与分段式各有优缺点，所以我们用段页式

![image-20220113191124328](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220113191124328.png)

在32为系统中，若页表大小是4096，则页表项有1024*1024个，也就是2^20

虚拟地址中页号占据虚拟地址的高20 位

3.段页式

> 综合了 分段式 和分页式，将内存进行分段，在每个段内采用分页管理







###  缺页中断

页表中有一个中断位---缺页中断，表示当前的虚拟地址要找的数据是否在物理内存中，（如果没在就会发生缺页中断

一个进程怎么会没在内存中呢？

内存管理

磁盘在分区的时候，至少有两个分区--

1.交换分区---用于内存不够时，将内存中的某些数据腾出来放到交换分区，腾出空间给紧急的数据处理，等到使用数据出发缺页中断的时候在交换回来

2、文件按系统分区---用于文件数据存储



到底应该将哪些数据放到磁盘上呢---内存置换法：最久未使用，最少未使用

## 进程控制

###  进程创建

### pid_t fork(void);

> 代码共享，数据独有![image-20220113193457566](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220113193457566.png)

内存管理的过程

子进程复制父进程，复制了pcb，页表，虚拟地址空间，所以一开始父进程处理个数据（标识符）之外都是一样的，并且父子进程的数据指向同一块物理内存，所以看起来父进程有什么，子进程也有什么

但是进程之间要保持独立性，数据独有，各有各的数据，因此当某一块空间的数据将要发生改变，则为子进程重新开辟物理内存，将数据拷贝过去

为什么不一开始就给子进程开辟空间呢？

> 如果这个子进程不适用，不就浪费了嘛，降低了进程创建的效率，还会造成内存冗余数据

所以我们采用写时拷贝技术

> 写时拷贝技术---为了提高子进程创建效率，毕竟有些数据从来不会改变，比如代码，重新开辟一块数据拷贝过去，没有意义，反而占据更多的内存

可以做到

> 进程拥有独立性，各有各的虚拟地址空间，映射各自数据存储
>
> 进程之间没有交叉关系，不会受到其他进程的影响，为了保证进程的稳定运行

返回值：对于父进程返回的是子进程的pid，是大于0的

​                对于子进程返回的是0

通过返回值可以进行父子代码分流

pid_t pid = fork();

if(pid < 0)  error

if(pid > 0) parent

if(pid == 0) child

![image-20220114083300978](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220114083300978.png)

###  pid_t vfork()

创建一个子进程，但是一个父进程使用vfork创建子进程之后，vfork的调用并不会立即返回（通常说会阻塞父进程），而是让子进程先运行，直到子进程退出，或者程序替换之后，父进程才能运行



vfork创建子进程有一个特殊的地方，**父子进程共用了父进程的虚拟空间**，所以子进程数据改变，父进程数据也会改变，在程序运行中，每调用一次函数，就会有一次函数压栈，函数调用栈

因为父子进程公用虚拟地址空间，使用了同一个栈，则若父子进程同时运行，就会造成调用栈混乱，让子进程先运行，直到子进程退出或者程序替换后有了自己的地址空间（在原有的地址空间中子进程的调用就都出栈了）

但是要注意，vfork创建的子进程，不能在main()函数中使用return退出，因为子进程使用return退出的时候释放了所有资源，父进程运行的时候资源是错误的











### 进程终止

方法一：

main函数中的return

![image-20220114084028840](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220114084028840.png)

![image-20220114083925610](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220114083925610.png)

---



![image-20220114084734592](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220114084734592.png)



![image-20220114084703376](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220114084703376.png)

方法二

> #include <stdlib.h>
>
> 在任意一个位置调用void exit(int status),可以在程序的任意一个位置退出一个进程



![image-20220114084947540](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220114084947540.png)

![image-20220114084914876](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220114084914876.png)



方法三

> #include <unistd.h>
>
> 在任意一个位置调用void _exit(int status),可以在程序的任意一个位置退出一个进程



![image-20220114085416985](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220114085416985.png)

![image-20220114085337481](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220114085337481.png)



看起来exit和_exit没什么不同呀

exit和_exit的区别

> 1.exit是库函数，_exit是系统调用接口
>
> 2.exit退出程序时，会刷新缓冲区，将缓冲区数据写入文件，_exit退出程序时，直接释放资源，不会刷新缓冲区



printf打印数据，实际上是把数据交给显示器，让显示器显示出来，涉及到了不同设备之间的数据交互

如果有很多小的数据要频繁交给显示器，效率是比较低的

因此操作系统做了一种优化

把很多小数据放到内存缓冲区中，积累成一个大的数据，然后让显示器一次性取出来，只有一次设备间的交互

因此printf没有立即把数据交给显示器，而是放到内存中（缓冲区），等到程序退出的时候，或者缓冲区刷新的时候才会把数据交给显示器

\n的作用

> 1.换行
>
> 2.刷新缓冲区（特定的显示器设备，通常称之为标准输出）



### 进程等待

#### 进程退出的场景

正常退出：完成任务，按照逻辑运行到return或者exit地方退出了

异常退出：没有完成任务，程序运行到半途因为某些原因崩溃退出

> 不管子进程时正常退出，还是异常退出，只要每被处理，就会产生僵尸进程

父进程等待子进程，为了获取退出子进程返回值，释放退出子进程所有资源，避免产生僵尸进程

僵尸进程产生的原因：因为子进程先于父进程退出，为了保存退出的返回值，而无法完全释放资源产生的

#### 如何等待

##### 方法一

int wait(int *status);

处理退出的子进程，那么如果调用这个接口的时候没有子进程已经退出，则会使父进程等待，直到有子进程退出

返回值：

> 成功返回处理的退出子进程的pid,失败则返回-1（比如没有子进程）

阻塞：为了完成一个功能，我们发起一个调用，但是若当前不具备完成功能的条件，则调用等待

非阻塞：为了完成一个功能，我们发起一个调用，但是若当前不具备完成功能的条件，则调用立即报错返回

status输出型参数，用于获取退出子进程的返回值

不等待的情况

![image-20220114103259475](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220114103259475.png)



![image-20220114104542851](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220114104542851.png)



等待的情况

记得包含头文件#include <sys/wait.h>



![image-20220114103908521](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220114103908521.png)

![image-20220114103817402](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220114103817402.png)

##### 方法二

int waitpid(int pid, int *status, int option);

也是处理退出的子进程，但是与wait不同之处

> 1.wait等待的是任意一个子进程的退出（wait是一个父进程假设有很多子进程，任意一个退出，都会处理后调用返回
>
> waitpid可以等待指定的子进程，也可以等待任意一个子进程，通过第一个参数确定（第一个参数pid==-1则表示等待任意子进程
>
> 2.wait是一个阻塞接口（wait如果没有子进程退出，则会一直等待）
>
> waitpid可以默认阻塞，也可以设置为非阻塞，通过第三个参数确定（第三个参数option==0表示默认阻塞；option==WNOHANG则表示非阻塞）

这是只判断了一次，但是如果正好错过，就不能避免僵尸进程，所以需要循环判断

![image-20220115000039257](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220115000039257.png)







![image-20220115000001347](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220115000001347.png)



![image-20220115000151311](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220115000151311.png)



需要循环判断

![image-20220115000827431](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220115000827431.png)



![image-20220115000740210](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220115000740210.png)

![image-20220115001023995](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220115001023995.png)





返回值

> 成功则返回退出子进程的pid大于0，若没有子进程退出返回0，若出错则返回-1



==非阻塞操作，通常需要循环处理，否则一次处理不成功，总不能不处理，得循环判断能否进行处理，直到成功==

两个接口的区别，在合适的地方使用合适的接口（比如 不想一直等待子进程退出，则使用非阻塞）

> 注意通过wait接口获取的子进程退出的返回值，返回值只使用了一个字节进行保存，并且在返回的时候，并没有存储在status的低位

一个进程退出的场景只有两个：正常退出，一茶馆退出，一个进程只有在正常退出的时候，返回值才是有意义的，若进程异常退出，返回值没有意义

因此在获取返回值之前，先通过低七位判断进程是否正常退出，（若正常退出，则异常退出信号值为0，若异常退出，异常退出信号值大于0）

进程怎么直到自己异常了？

> 一个进程是否产生了异常，是操作系统检测到的，通知的进程，而信号就是进程中的异常通知的值，不同的值表示不同的异常

前面我们知道返回值被存在了低16 位中的高八位，那如何得到正确的返回值呢

> 1.首先先判断返回值是否有意义，因为异常退出的返回值是没有意义的，页没必要求取返回值
>
> 如何取出低7位
>
> 判断方法：status & 0x7f == 0就能判断一个进程是正常退出
>
> 如何取出低16位中的高8位？
>
> （status >> 8)&0xff
>
> 》 因为返回值只用了一个字节保存，因此进程的返回值最好不要大于255
>
> 



获取进程返回值的两种方法

1.

![image-20220115093852082](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220115093852082.png)



![image-20220115093947455](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220115093947455.png)





方法二

> 利用man waitpid查看手册

![image-20220115095613213](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220115095613213.png)





![image-20220115095033290](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220115095033290.png)

![image-20220115094856644](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220115094856644.png)



额外介绍：系统调用接口出错后，如何获取错误原因

> #include <errno.h>
>
> #include <string.h>
>
> char *strerror(errno);根据错误编号获取文字信息，错误都是上一次系统调用接口使用错误的原因
>
> perror(char *msg);直接打印上一次系统调用接口使用错误的原因



![image-20220115110424825](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220115110424825.png)

#### 程序替换

![image-20220115113935576](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220115113935576.png)





![image-20220115121938846](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220115121938846.png)

### 基础IO



### 进程间通信



### 进程信号



### 多线程

 

  