##  Linux

## 第一节 、基础指令

### Linux下基础指令

####  1.目录命令

#####  `ls`

```
ls [选项][目录或文件]
```

**功能** ：列出改目录下的所有子目录与文件,这是最最最常用的命令了

>* -a:列出目录下所有文件，包括.开头的隐含文件
>
>* -l:列出文件的详细信息

##### `pwd`

```
pwd
```

**功能**：显示用户当前所在目录---打印出来的是绝对路径

##### `mkdir` 

```
mkdir [选项] dirname
```

**功能**：在当前目录下创建一个名为"dirname"的目录

> * -p:可以是一个路径名称，此时若路径中的某些目录尚不存在，加上这个选项后，系统将自动建立好那些尚不存在的目录，即一次可以创建多个目录

*示例：mkdir -p test*---可以递归创建多个目录

有创建自然就有删除，删除有两个指令，一个是rmdir ,一个是rm,我们可以对比学习

##### `rmdir`

```
rmdir [-p][dirName]
```

**功能**：rmdir的功能是删除空目录，只能删除空目录！

> * -p:加上这个操作，当子目录被删除以后，如果他的父目录也变成空的，就连带父目录一起删除

##### ` rm `

```
rm[-f -i -r -v][dirNmae/dir]
```

**功能**：rm命名可以同时删除文件或是目录

> * -f:使文件属性为只读，亦直接删除
> * -i:在删除前一个一个询问你要不要删除
> * -r:删除目录即其下所有文件

##### `cp`

```
cp [选项]源文件或目录  目标文件或目录
```

**功能**：用于复制文件或目录---copy嘛

如果同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则它会把前面指定的所有文件或目录复制到此目录中。若同时指定多个文件或目录，而最后的目的地并非一个已存在的目录，则会出现错误信息

>* -f:---force强行复制或目录，不论目的文件或目录是否已经存在
>* -i:---interactive覆盖文件之前询问你要不要覆盖
>* -r:递归处理，将指定目录下的文件与子目录一并处理

##### `mv`

```
mv [选项]源文件或目录 目标文件或目录
```

1.当第二个参数是文件时，mv命令是给文件重命名，此时只能有一个源文件 

2.当第二个参数是已经存在的目录时，源文件或目录参数可以有多个，mv将各参数指定的源文件均移至目标目录中

> * -f: force强制，如果目标文件已存在，不会询问而直接覆盖
> * -i: 如果目标文件已经存在时，会询问是否覆盖

##### `cd `

```
cd 目录名
```

**功能**：改变工作目录，将当前工作目录改变到指定的目录下

> * cd .. :返回上级目录
> * cd /home/lmr/linux/ :以绝对路径进入新的工作目录
> * cd ../lmr02/ :以相对路径进入新的工作目录
> * cd ~ :进入家目录

补充一点：`..`表示当前目录的上一级目录

​                  `.`表示当前目录自身

**linux下的目录结构是唯一的树形结构,目录结构不会随着磁盘分区而改变**

**tap键自动文件名补全**

💙💙💙💙💙💙💙💙💙💙💙💙💙平平无奇的分界线💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙

####  2.普通文件命令

文件的时间属性有三种：最后一次访问，最后一次修改，最后一次状态改变

##### `touch`

```
touch [选项]...文件...
```

**功能**：touch一个文件，若存在则刷新文件的时间属性，若无，则创建一个文件

> -d   使用指定的时间刷新时间属性

> -a   仅使用当前系统事件刷新访问时间

> -m  仅使用当前系统事件刷新修改时间

*示例：touch -d "2012-12-12 12:12:02" passwd*

##### `cat`

```
cat [选项][文件]
```

**功能**：打印文件信息直接显示在终端上

*示例：cat passwd*

##### `more`

```
more [选项][文件]
```

**功能**：分页显示文件内容

> 回车：向下按行滚动
>
> 空格：向下按页滚动
>
> q键：退出显示

#####  `less`

```
less [参数]文件
```

**功能**：分页显示文件内容

> * ⬇ 回车：向下按行滚动
>
> * 空格 f键：向下按页滚动
>
> * ⬆ b键：向上滚动
>
> * q键：退出显示
> * /string :向下匹配查找字符串
> * ？string：向上匹配查找字符串

##### `head`

```
head [参数]...[文件]...
```

**功能**：显示档案的开头至标准输出中，默认显示文件前10行内容

> * -n:指定显示的行数

#####  `tail`

```
tail [必要参数][选择参数][文件]
```

**功能**：用于显示指定文件末尾内容，不指定文件时，作为输出信息进行处理。默认显示文件末尾10行内容

>* -n:指定显示的行数
>* 动态一直等待文件末尾的新数据进行

💙💙💙💙💙💙💙💙💙💙💙💙💙平平无奇的分界线💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙

####  补充命令

##### `echo`

**功能**：打印字符串--将数据写入标准输入--显示器设备文件

##### `start`

**功能**：查看文件状态信息

##### 重定向

`>>`或`>`叫做重定向符号，作用是进行数据流的重定向，即文件的重新定向，将要操作的数据，不再写入原本的文件，而是写入新的文件中

*示例：echo "abcd">>text.txt*---将原本要写入标准输出文件的数据，写到text.txt文件中

> `>>`:追加重定向,将数据重新定向到指定的文件中,但是新数据会追加写入到文件末尾
>
> `>`:清空重定向,将新数据重定向到指定的文件中,但是在这之前会清空文件原有的内容

##### 管道符

`|`:head -23 ./passwd | tail -n 1

连接两个命令,将前面命令输出结果,当作后面命令的输入数据,让后面的命令进行处理

##### `ifconfig`

查看网卡信息

##### `shutdown -h now`

关机命令

##### `man`

手册查看命令

*man ls*:查看ls命令的手册

*man fopen*:查看fopen函数的手册

💙💙💙💙💙💙💙💙💙💙💙💙💙平平无奇的分界线💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙

#### 3.压缩文件命令

压缩和打包是不同的

* 压缩:将一个文件按照一些压缩算法,将文件数据从多变少

##### `zip/unzip`

```
zip/unzip 压缩文件.zip 目录或文件
```

zip格式的压缩,文件后缀名.zip

##### `gzip/gunzip`

```
gzip/gunzip 文件或目录
```

gzip格式的压缩,文件后缀名.gz

##### `bzip2/bunzip2`

```
bzip2/bunzip 文件或目录
```

bzip2格式的压缩解压缩,文件后缀名.bz2



* 打包:将多个文件合成一个文件

##### `tar`

```
tar -czvf ***.tar.gz **.txt**.txt//打包
```

```
tar -xvf ***.tar.gz//解包
```

linux下使用度最高的打包解包工具,将多个文件打包成为一个文件,提供解包功能,并且打包解包的同时可以进行压缩解压缩

> * -c:打包
> * -x:解包
> * -z:打包同时进行gzip格式的压缩解压缩
> * -j:打包解包过程同时进行bzip2格式压缩解压缩
> * -v:显示打包解包信息
> * -f:用于指定tar包名称,通常是作为最后一个选项,因为后面要跟上打包名称

💙💙💙💙💙💙💙💙💙💙💙💙💙平平无奇的分界线💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙

####  4.匹配查找命令

##### `grep`

**功能**:从文件内容中匹配包含某个字符串的行,常用于在某个文件中找函数

> * -i:匹配时忽略大小写
> * -v:反向匹配,匹配不包含指定字符串的行
> * -R:对指定目录下的文件递归逐个进行内容匹配

##### `find`

**功能**:从指定目录中查找指定名称/大小/时间/类型的文件

> * find ./ -name "\*test*" 通过文件名查找文件
>
> * find ./ -type d 通过文件类型找文件----->f:普通文件  d:目录文件   c:字符设备   b:块设备   p:管道设备  l:符号链接文件  s:套接字文件
> * find ./ -size -10M  通过文件大小找文件---->10M以内的文件   +10M时超过10M的文件
> * find ./ -mmin -10 通过文件时间找文件---->cmin/mmin/amin以分钟为单位    ctime/mtime/atime 以天为单位

💙💙💙💙💙💙💙💙💙💙💙💙💙平平无奇的分界线💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙

### shell的理解

📍为什么在终端中输入一串字符串,回车会被当做命令行,完成某个功能?

shell是操作系统内核与用户之间的桥梁---命令行解释器

用户不能直接访问系统内核----直接访问太危险

shell会捕捉用户的标准输入,得到字符串,通过字符串判断用户想要干什么

用户不能直接访问内核,操作系统提供一些接口,系统调用接口用户只通过这些接口来完成内核某个特定功能的访问

浏览目录这种功能会涉及到很多系统调用接口,为了便于用户使用,因此大佬使用又使用系统调用接口封装了一些直接完成常用功能的程序

功能程序---被称为shell命令程序

用户输入ls字符串,shell捕捉到之后,就会执行ls这个命令程序完成浏览目录的功能

📍终端为什么能够执行命令?

因为终端打开之后默认就运行了一个程序---->shell---->命令行解释程序

shell程序多种多样--->bash dash csh

我们执行命令都是一个个程序---->我们在终端中输入什么字符串,shell捕捉到之后,就会执行什么程序,完成对应功能

windows下的shell就是ui操作界面

### Linux的权限

**权限**:控制一个用户权利的东西

📍为什么要有权限

> 如果每个人都可以干任何事情,则秩序是混乱的

Linux下有两个用户:**超级用户/普通用户**

su命令进行用户切换---->目的就是为了获取这个用户的操作权限

##### 文件的权限

文件权限的操作指令：描述哪个用户可以对文件如何操作

文件访问用户的分类：文件所有者-u，文件所属组-g，其他用户-o

文件访问操作的分类：可读-r，可写-w，可执行-x

##### 权限表示

显示字符表示：rwx rwx r--

八进制数字表示：7 7 4

##### 文件访问权限指令

定义：创建一个文件的默认权限

##### `umask`

**功能**：查看或设置文件的创建权限掩码，也就是说掩码决定了一个文件的创建的默认权限

> * -S：人性化显示---->计算方法：777满权限-八进制掩码----->正规计算方法：给定权限&（~掩码）777&（~002）
> * 目录：可浏览-r,可在目录下删除创建文件-w,可进入-x

创建好的文件的权限修改

##### `chmod`

> * chmod 777 hello.txt 直接使用八进制数字进行修改
> * chmod a-x hello.txt 针对某类用户进行权限的删除或增加 `chmod [augo]+/-[rwx] filename`

文件用户信息的修改

##### `chown`

> * `chown username filename`修改文件所有者（只能使用root修改）

##### `chgrp`

> * `chgrp groupname filename`修改文件所属组

##### 文件权限的沾滞位

粘滞位是一个特殊的权限位--->主要用于设置目录粘滞位，其他用户在这个目录下创建文件，可以删除自己的文件，不能删除别人的

> * chmod +t filename

💙💙💙💙💙💙💙💙💙💙💙💙💙平平无奇的分界线💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙

## 第二节、常用工具

### 1.软件包管理工具

#### 什么是软件包

> * 在Linux下安装软件，通常的办法是下载到程序的源代码，并进行编译，得到可执行的文件
> * 但是这样太麻烦了，所以有些人把一些常用的软件提前编译好，做成了软件包
> * 软件包和软件包管理器，就类似于手机上的应用商店
> * `yum`是Linux下非常常用的包管理器

#### `yum`三班斧

##### 1.查看

> * `yum` `list`---->查看所有软件包
> * `yum` `search`---->搜索指定软件包

##### 2.安装

> * 首先要进入管理员权限 ---->`su` `root`
> * `yum` `install`---->安装软件包

##### 3.移除

> * 首先要进入管理员权限---->`su` `root`
> * `yum` `remove`----->卸载安装包

我们想查看常用工具是否已经安装，可以查看每个工具的版本信息，如果找不到就代表没有安装

例如

> * `vim` `--version`
> * `gcc` `--version`

**注意**：关于`yum`的所有操作必须保证主机网络畅通

💙💙💙💙💙💙💙💙💙💙💙💙💙平平无奇的分界线💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙

### 2.编辑器

#### `vim`

`vim`是一个命令行编辑器，其中不能使用鼠标----在命令行中实现光标的移动，文本的操作，文本的编辑

#### vim操作模式

总共有12种，常用三种：

> 1.**插入模式**：进行文本数据的编辑插入
>
> 2.**普通模式**：进行文本常见的操作-复制、剪切、粘贴、删除、撤销、返回、文本对齐、光标移动
>
> 3.**底行模式**：进行文本的保存和退出，以及文本的匹配查找替换操作

#### vim使用

##### 打开文件

`vim filename`---->打开一个已有的文件若不存在就会创建，打开后默认处于普通模式

##### 操作模式的切换

所有模式都是围绕普通模式进行切换的

> 1.普通模式--->插入模式 
>
> * 按`i`/`a`/`o`/`I`/`A`/`O`从普通模式进入插入模式
> * 按`i`进入插入模式，是从光标当前位置开始输入文件
>
> * 按`a`进入插入模式，光标后移一个字符开始插入
> * 按`o`进入插入模式，在光标下面新插入一行，在行首开始插入,
> * 按`I`进入插入模式，是从光标所在行的行首开始插入
> * 按`A`进入插入模式，从光标所在行的行尾开始插入
> * 按`O`进入插入模式，在光标所在上一行插入新行，在行首进行插入

> 2.普通模式--->底行模式 
>
> * 英文`:`，从普通模式到底行模式
> * `:q`退出
> * `:w` 保存
> * `:wq`保存并退出
> * `:q!` 不保存的强制退出

> 3.其他模式--->普通模式
>
> * 任何模式下按`ESC`键，都可以返回普通模式

##### 普通模式下的操作指令

###### 1.光标移动

> * `h`/`j`/`k`/`l`:按字符的上下移动
> * `w`/`b`：按单词的左右移动
> * `ctrl`+`f`/`b`：上下翻页
> * `gg`/`G`：首行/尾行

###### 2.文本操作

> * `yy`：将光标所在之处到字尾的字符复制到缓冲区中
> * `nyy`：复制从光标所在行往下数的n行文字
> * `dd`：删除光标所在行
> * `ndd`：删除从光标开始行往下的n行
> * `x`：删除字符
> * `dw`：删除单词
> * `p`：将缓冲区的字符粘贴到光标所在位置
> * `P`：将缓冲区的字符粘贴至光标所在上一行

在vim中没有剪切，删除就是剪切，虽然看到数据被删除了，但是也复制到剪切板上了

###### 3.其他操作

> `u`：撤销上一次操作
>
> `ctrl`+`r`：撤销的反向操作
>
> `gg=G`：全文对齐

##### `sudo `

**功能**：临时为用户操作提权，不用每次都切换到管理员用户了

但是`sudo`是需要配置的

> 1.`su` `root` 切换到管理员用户
>
> 2.`visudo` 打开`sudo`配置
>
> 3.:90 跳转到文档第90行，90 行附近
>
> 4.`yy`复制`root`这一行，p粘贴
>
> 5.将用户名从`root`变成自己的用户名称
>
> 6.`:wq`保存退出

💙💙💙💙💙💙💙💙💙💙💙💙💙平平无奇的分界线💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙

### 3.编译器

#### `gcc/g++`

`gcc`是C语言编译器，`g++`是c++语言编译器，不同的语言有不同的编译器

#### 编译器作用

C语言，C++语言都是高级语言，机器无法识别这些代码，需要编译器，将高级语言代码解释成为机器指令，生成可执行程序文件再能执行

可执行程序文件：一段功能的机器指令集

**编译型语言**：c/c++   

> 程序编译后才可以执行 ，运行性能高，编码较慢

**脚本型语言** ：python/lua/shell  

> 编写完毕直接执行  逐行解释型语言，由解释工具逐行解释，然后执行功能，编码较快，但运行性能低

#### 编译过程

##### 1.预处理

```
gcc  -E a.c -o a.i
```

```
gcc  -E b.c -o b.i
```

> 展开所有代码（引入头文件，宏替换，删除注释...）`gcc` `-E`（只预处理）

##### 2.编译

```
gcc -S a.i -o a.s
```

```
gcc -S b.i -o b.s
```

> 进行语义语法纠错，没有错误将代码解释成为汇编代码 `gcc` `-S`（只进行编译）

##### 3.汇编

```
gcc -c a.s -o a.o
```

```
gcc -c b.s -o b.o
```

> 将汇编代码解释成为机器指令`gcc` `-c`（只进行汇编）

##### 4.链接

```c 
gcc a.o b.o -o main
```

> 将所有用到的机器指令文件打包到一起，生成可执行程序`gcc` `-o`（指定要生成的文件名称）

📍我们在C语言中并没有定义printf函数，而且在预编译中包含的头文件中也只有函数的声明，那是哪里实现printf函数的呢？

这里引入一个重要概念

#### 函数库

![image-20220106134726937](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220106134726937.png)

图中libc是标准c库，printf就是标准c库中的函数，

**gcc编译器在链接生成可执行程序的时候，会自动链接标准c库**

###### 链接库文件的两种方式

> gcc中默认动态链接

1.**动态链接**：链接动态库，在可执行程序中记录函数符号信息表，生成的可执行程序比较小，但是运行时需要加载动态库，多个程序会在内存中使用同一个相同的库，不会再内存中造成代码冗余

2.**静态链接**：链接静态库，直接将使用的函数实现写入可执行程序中，生成的可执行程序比较大，但是运行时不需要额外依赖加载库文件，但是如果多个程序使用了相同的静态库，则运行起来会在内存中造成代码冗余

![image-20220106141213779](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220106141213779.png)

💙💙💙💙💙💙💙💙💙💙💙💙💙平平无奇的分界线💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙

### 4.调试器

#### `gdb`

* 调试一个程序的运行过程，能让我们从运行过程中发现程序哪里有问题，可以适当的改变数据达到某种调试目的

* 不是所有的程序的都可以调试，调试器只能调试具有调试符号信息的程序--->debug版本的程序

* gcc生成可执行程序，默认会生成release版本的程序，程序中没有调试符号信息，想要生成debug版本需要加上`-g`选项

  > * gcc -g a.c b.c -o mian

##### 1.调试器加载程序

> * `gdb` `./main`   直接使用gdb加载程序

##### 2.开始调试程序

> * run  直接运行
> * start   开始逐步调试

##### 3.常用调试指令

**1.流程控制**   

> * `next`/`n`：下一步，遇到函数直接运行，不会跟踪进入
> * `step`/`s`：下一步，遇到函数则跟踪进入函数
> * `list`/`l`：默认查看调试行附近代码，也可指定行--->`list` `file`:`line`
> * `until`:直接运行到指定行，也可以指定文件--->·`until` `a.c` `line`
> * `continue`/`c`：继续运行，直到断点处停下

**2.断点操作**

> * `break`/`b` `指定文件` :`指定行`：给指定文件的指定行打断点
> * `break` `function`：给函数打断点
> * `info` `break`：查看断点信息
> * `watch` `变量`：给变量打断点，放变量数据改变的时候停下
> * `delete`/`d`：删除断点

**3.调用栈操作**

> * `print`/`p`：查看变量数据---->print a;  `print` `a`=10---->设置变量数据
> * `backtrace`/`bt`：查看程序运行调用栈信息，程序一旦崩溃，查看调用栈可以快速定位崩溃位置--->栈顶函数

![image-20220106154809086](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220106154809086.png)

💙💙💙💙💙💙💙💙💙💙💙💙💙平平无奇的分界线💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙

### 5.项目自动化构建工具

#### `Makefile`/`make`

> Makefile:普通文本文件，用于记录项目的构建规则流程

> make:Makefile解释程序，逐行解释Makefile中项目的构建规则，执行构建指令，完成项目的构建

##### `Makefile`的编写规则

第一步.目标对象：依赖对象

第二步.制表符`\t` 执行指令

> **目标对象**：是要生成的可执行程序的名称

> **依赖对象**：是生成目标对象所需要的源码文件

如果你出现了和我一样，下面这张图的错误，不同担心，这代表编辑 makefile 时出现格式错误了

![image-20220106163149872](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220106163149872.png)

**记住**：第二行gcc前面需要按下`Tap`键来空出空格，其他的都无效

![image-20220106163347609](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220106163347609.png)

修改以后，就没有问题了

![image-20220106163539429](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220106163539429.png)

##### `make`的解释执行规则

1.make一旦执行，就会在当前目录寻找Makefile

2.make的执行规则中，要生成目标对象，首先要保证依赖对象已经生成，若没有生成，则会递归向下寻找依赖对象的生成规则

![image-20220106173228043](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220106173228043.png)

3.在Makefile中找到第一个目标对象，根据依赖对象的时间关系，判断是否需要重新生成

> * 生成第一个对象后，make就会退出，不会继续生成第二个对象
>
> * 📍如果非要生成两个对象呢？
>
> * > 也可以
>
>   ![image-20220106170900645](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220106170900645.png)
>
>   方法如上图，结果如下图
>
>   ![image-20220106171024069](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220106171024069.png)

4.若是需要重新生成，则执行对应下方的指令（指令不是非要生成对象的指令，也可以是打印等）

##### `make`的编写执行规则进阶版

make 中的预定义变量

> * $@：表示目标对象
> * $^：表示所有依赖对象
> * $<：表示所有依赖对象中第一个依赖对象
>
> ![image-20220106173523309](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220106173523309.png)
>
> 这样是不是还有点麻烦，通配符%的使用
>
> ![image-20220106174238344](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220106174238344.png)
>
> 简洁多了~

##### 伪对象的声明使用

```c++
.PHONY：目标对象的名称
```

**作用**：不管对象是否最新，每次都要重新生成

![image-20220106180938871](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220106180938871.png)

💙💙💙💙💙💙💙💙💙💙💙💙💙平平无奇的分界线💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙

### 6.项目版本管理工具

#### `git`

`git`:项目的版本管理工具

> 版本管理工具：对项目的开发周期进行管理，每一次提交的修改都会有对应的版本号，能够让我们在程序的时候回滚回去

##### `git`使用

1.从远程仓库克隆到本地

> git clone URL

2.本地提交修改信息

> git add ./*

3.提交本次版本管理

> git commit -m "内容"

4.将本次版本提交到远程服务器仓库

> git push origin master

**origin**用于指定分支名称

> git config --global user.name
>
> git config --global user.email

## Linux系统编程

系统编程就是学习进程的各个操作，所实现的功能，以及实现原理，流程等

### 进程概念

想要了解进程的概念,要从以下六个部分进行理解

首先,先了解什么是冯诺依曼体系结构

#### 1.冯诺依曼体系结构

##### 📍什么是冯诺依曼体系结构?

> 冯诺依曼体系结构即现代计算机的硬件体系结构：计算机应该包含五大硬件单元
>
> > 1.输入设备：采集数据
> >
> > > * 比如键盘，鼠标,扫描仪,网卡接收网络中的数据
> >
> > 2.输出设备：进行数据输出
> >
> > > * 比如显示器，打印机,网卡向网络中发送数据
> >
> > 3.存储器：进行数据中间数据缓冲
> >
> > 4.运算器：进行数据运算
> >
> > 5.控制器：进行设备管理

**运算器+控制器**就是CPU中央处理器

##### 📍图解

![image-20220108155228670](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220108155228670.png)



##### 📍所有的设备都是围绕存储器工作的

> * cpu不会直接从输入设备获取数据进行处理，而是先把数据放到存储器中，cpu从存储器中获取数据处理
> * cpu不会直接将数据交给输出设备进行输出，而是先把数据放到存储器中，控制输出设备从存储器中获取数据输出

📍既然所有的设备都是围绕着存储器工作的,那存储器是什么呢?

> * 存储器就是我们常说的内存

📍我们熟知电脑还有个叫硬盘的东西，为什么存储器是内存而不是硬盘呢?

> * 因为硬盘的吞吐量太低了,正常的机械硬盘是200MB/s
> * 内存的吞吐量是己写硬盘的数十倍

📍那内存的速度那么快,为什么内存只用于缓冲,不使用内存存储数据,而用硬盘存储呢?

> * 主要是因为硬盘与内存的存储介质是不同的
> * 内存是易失介质,数据在断电后就会丢失,而硬盘断电后数据不会丢失

接下来我们了解什么是操作系统

#### 2.操作系统

##### 📍1.什么是操作系统

> 操作系统一个“搞管理”的,（安装在计算机上的一个程序）任何一个计算机系统都包括操作系统(`os`),用来管理计算机上的软硬件资源

##### 📍2.操作系统包括啥

> * 内核
>
>   > 用来完成进程管理，内存管理，文件管理，驱动管理等
>
> * 外部应用
>
>   > 函数库，shell程序等，是为了让系统更加好用，作为系统和用户之间的桥梁

##### 📍3.为什么需要操作系统来管理

> * 用户是无法直接访问内核的，只能通过系统调用接口来访问，用户直接访问内核的`危险性`太高了
> * 为了控制风险，“听系统的话”，操作系统会向外提供访问内核的接口，这个接口就称为`系统调用接口`

##### 📍4.操作系统怎么管理

操作系统给管理方法叫：`先描述` `在组织`

###### 举例

为了更好的理解，我们引入一个例子

学校管理体系大致分为三部分：管理者，被管理者，执行者

> * 学生：自然是`被管理者`啦
>
> * 导员，老师，宿管阿姨：这些都是管学生的人，但是他们不是管理者，他们只是制度的`执行者`，真正的管理者是制度制定者
>
> * 校长：制定制度，`管理者`

###### 📌校长是怎么管理学生的呢？

假如有一个学生非常不听话，要被开除，怎么样才叫被开除呢？

* 解法一：把这个学生踢出学校，再也进不了学校的大门

> * NO

* 解法二：在这个学生后背贴上”已被退学“

> * NO

* 解法三：在这个学生的学籍档案上盖章——勒令退学

> * YES(好可怕，不要被退学~)

这样我们可以大致了解校长是怎么管理学生的----学籍档案

> 校长并不需要知道你是谁，但是他手里有你的学籍档案，你就要被”管“啦

学籍档案是什么

> 是你从上学以来的学籍信息，是一个学生的描述信息

这就是你被描述起来了

光有学籍档案就可以管理了嘛，全国有那么多学生，我要从中多的档案中找到你，得花不少时间吧

这就要谈到组织了

> 虽然学生有那么多，但是可以组织起来，分到不同的省，不同的市，不同的学校，不同的学院，不同的班级，是不是就很好找了

现在知道是怎么管理的嘛

>  从你开始上学，将你的信息收集起来，描述起来，然后放到学籍管理系统中组织起来进行管理

其实操作系统就是差不多的管理过程啦

###### 📌计算机管理硬件

> * 描述起来，例如将键盘，鼠标等用struct 结构体描述起来
> * 组织起来，利用链表或其他高效的数据结构

###### 📌流程看图解

![image-20220108155210087](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220108155210087.png)

##### 📍5.理解系统调用和库函数

> * 从开发角度看，操作系统把自己包成了一个球，但是会暴露`部分接口`，供上层开发使用，这个由操作系统提供的接口，就叫`系统调用接口`
> * 但是这个系统调用在使用上很难，他对于使用者的`要求太高`了（因为功能非常基础，用起来很费劲），所以有些开发者对部分系统调用进行了`封装`，形成了`库`，有了库以后，就极大`方便了`用户或是开发者的使用

了解完操作系统，接下来就要理解什么是进程了

#### 3.进程概念

##### 📍操作系统是怎么管理进程的呢？

> * 先把进程描述起来
> * 再把进程组织起来

我们可以看一下自己的任务管理器，它显示了我们有哪些正在运行的进程

![image-20220108153205292](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220108153205292.png)

##### 📍那什么是进程?

> * 我们课本上的概念：进程是一个程序的执行实例，正在执行的程序等
> * 内核：是担当系统分配资源的实体

🙌没听懂，有必要深入了解一下

* 一个程序运行起来，有数据和指令需要被CPU执行处理
* 根据我们所学的冯诺依曼体系结构（忘记了可以去上面复习）[点击跳转冯诺依曼](#什么是冯诺依曼体系结构?),CPU不会直接去硬盘上找程序文件进行执行处理
* 他会先将程序的数据信息加载到内存中，然后CPU从内存中获取数据以及指令进行执行处理

###### 📌操作系统中的进程都是同时运行的

> * 这个不难理解，就像我们的手机可以同时看小说、听音乐
> * 但是，我们假设只有一个cpu,是如何做到多个程序同时运行的呢？
>
> * > CPU的`分时机制`
>   >
>   > * CPU只负责执行指令，处理数据，至于处理哪一个程序，CPU并不关心
>   >
>   > * 把CPU比喻成流水线上的员工，他只负责有一个包裹过来了，就接收它，处理它，至于什么是包裹~完全不看
>   >
>   > * 那负责决定放什么包裹，什么时候放放包裹的，是谁呢？
>   >
>   > * > 是`操作系统`,操作系统对程序的运行进行调度管理
>   >
>   > * 所以CPU进行程序处理的时候不会一次性的将一个程序运行完毕才会运行下一个，而是每个程序都运行一个很短的时间，这叫`分配时间片`，时间片运行完毕，由操作系统进行调度，让另一个程序的代码数据在cpu上进行处理

###### **补充** 

###### 📌什么是调度

> * 操作系统将程序的信息放到cpu寄存器中，让cpu知道执行哪一个程序的哪一个指令，处理什么数据
> * 如果此时有多个程序运行，cpu分时机制会实现程序之间的切换
> * 如何切换，就是调度

###### 总结

* cpu分时机制实现cpu轮询处理每一个运行中的程序，而程序运行调度由操作系统进行管理

* 回到第一个问题，操作系统是怎么管理的呢 

* > 操作系统将每一个程序的运行信息保存下来，进行调度管理，所以下一次程序被分到时间片的时候才能知道这个程序上一次运行到哪里

###### 图解

![image-20220108153356132](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220108153356132.png)

> 如图，操作系统就是调度程序在1，2，3，4，5，6中来回分配时间片，时间很短，反正我们是感受不到的

###### 所以什么是进程

> * 程序的指令或数据不动，在内存中就是死的，称不上叫进程
> * 操作系统通过对一个程序进行描述，让一个程序运行起来
> * 对于操作系统来说，进程就是PCB(如上图)是一个程序运行的动态描述，通过PCB，才能实现程序运行的调度管理

`进程`--`PCB`

> 进程信息被放在一个叫做进程控制模块的数据结构中，我们称为PCB（process control block)

###### Linux下的PCB

`task_struct`

> * task_struct是Linux下的描述进程的
>
> * task_struct是Linux内核的一种数据结构，它会被装载到内存中，并且包含进程的信息

`task_struct`内容分类

> * 内存指针--->包括程序代码和进程相关数据的指针，还有其他进程共享的内存块的指针
> * 上下文数据--->进程执行时处理器的寄存器中的数据
> * 程序计数器--->程序中即将被执行的下一条指令的地址
> * 标示符--->描述本进程的唯一标识符，用来区分其他进程
> * IO状态信息--->显示的IO请求，分配给进程的IO设备，被进程使用的文件列表
> * 优先级--->相对于其他进程的优先级
> * 记账信息--->处理器时间总和，使用的时钟数总和，时间限制，记账等

**并行**：cpu资源不够的情况下，采用cpu分时机制，任务轮询处理

**并发**：多核cpu，多个进程同时占据cpu进行数据处理

#### 4.进程状态

为了弄懂正在运行的进程是什么意思，我们需要在知道进程的不同状态

Linux对进程状态进行细分

1.运行：包含正在运行以及就绪，运行态就是一个进程拿到时间片就能进行数据处理的状态

2.可中段休眠：指的是休眠可以唤醒，条件自然满足后唤醒，也可中断，被中断后置为运行态

休眠：暂时不需要cpu调度运行，让出cpu资源，休眠也有唤醒条件，会查看状态，如果是休眠，就会看唤醒条件是否满足，如果满足，则置为运行状态，进行处理，如果不满足则切换下一个进程

3.不可中断休眠：必须等到唤醒条件自然满足后才置为运行态

4.停止：停止与休眠不一样，停止只能手动唤醒

5.僵尸状态：描述一个进程退出了，但是进程资源没有完全释放，呈等待处理的一种状态

#### 5.环境变量

概念：就是一个变量，用于存储系统运行的环境参数

作用：

> * 通过修改环境变量的值，灵活配置下hi同运行环境参数（是系统环境配置更加灵活）
> * 子进程的继承性，（子进程会默认拥有父进程相同的环境变量，可以通过环境变量进行进程之间的数据传递）

命令操作

> * env
> * set
> * echo
> * export
> * unset

通过代码获得环境变量

> main函数的第三个参数
>
> * 使用extern char **environ
> * char *getenv(char *key)

代码中设置环境变量

> * setenv(char *key, char val, int override)
> * putenv(cahr *key = val)

#### 6.程序地址空间

![image-20220116210036948](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220116210036948.png)

程序地址空间，就是操作系统为进程使用mm_struct结构体描述的一个虚拟的地址空间

地址：

> 内存地址，队内存以字节为存储单位的一个编号
>
> 通过地址就能找到具体对应的内存单元

程序

> 程序就是一堆死代码，保存在程序文件中（硬盘），编译器在编译程序生成可执行文件时，就会对每一条指令，每一个数据，进行一个地址编号
>
> 当程序运行的时候，就会将指令以及数据放到指定位置的内存地址位置
>
> cpu就会根据地址偏移逐步去执行指令，以及找到对用的数据进行处理
>
> 程序运行之后才会占据内存，因此程序地址空间通常被称为进程地址空间

进程地址空间到底是什么

> * 如果真的将物理内存分成了不同的区域，代码段存放的是代码，（只读的，不能修改）
> * 如果物理内存有一段不可修改，那数据又是怎么放进去的
> * 一个内存地址只能指向一个唯一的内存单元，一个内存单元只能存储一个数据
>
> * 其实进程中所访问的地址都是虚拟地址，都是一个假地址，并非物理内存的地址
> * 我们所说的程序地址空间，实际上也是一个虚拟的地址空间
> * 是操作系统为进程通过一个mm_struct结构体所描述的一个假的地址空间
> * mm_struct (task_size, start_code, end_code)，通过大小以及区域的编号描述

原来如此

> * 原来我们所说的地址空间是一个虚拟的地址空间，只是一堆地址编号的描述（并非物理内存地址）



> * 为什么操作系统不让进程直接访问物理内存，而是弄了一个虚拟地址空间，让进程访问虚拟地址呢？

📍若进程直接访问物理内存，有什么不好？

> 1.程序在编译时，编译器就会给指令和数据进行地址编号，但是如果某个地址内存已经被占用，则程序就运行不起来了--编译器的地址管理麻烦（无法动态获知拿快内存是否被使用，也无法进行代码以及数据的地址赋值）
>
> 2.进程直接访问物理内存，如果有一个野指针，在操作的时候可能就把其他进程的数据改变了（无法进行内存访问控制）
>
> 3.程序加载通常需要使用一块连续的内存空间，内存利用率很低

通过虚拟地址空间映射到物理内存上进行数据存储，可实现数据在物理内存上的离散式存储，提高内存的利用率

并且每个进程都有自己的虚拟内存空间，因此对于每个进程来说，都会拥有自己的一块连续的空间使用

> * 虚拟地址是不具备存储能力，数据的存储依然还是要放到物理内存中段的起始位置一样，但是每个变量的偏移量不同），因此，通过段号对应的物理内存段起始地址以及虚拟地址中的偏移量组成一个完整的物理内存，找到对应的物理内存单元
> * 优点：对编译器的地址管理比较友好
> * 缺点：没有解决数据连续存储内存利用率低的问题，因为一个段管理了很多变量数据，这些变量就都从同一个起始位置进行偏移，也就在物理地址中使用了连续的地址空间（分段号式管理中，同一个段内数据都使用了连续的地址空间）每个段之间不用连续，但是段内是连续的



> * 进程中访问的都是虚拟地址，问题来了，如何通过虚拟地址找到物理内存呢？（虚拟内存和物理内存有什么关系）

##  操作系统中内存管理方式

1.分段式

![image-20220116214812504](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220116214812504.png)'

\]

> 将虚拟地址的组成分为段号+段内偏移量（比如全局数据段有很多变量，他们的段号都是一样的，也就意味着段的起始位置一样，但是每个变量的偏移量不同），因此，通过段号对应的物理内存段起始地址以及虚拟地址中的偏移量组成一个完整的物理内存，找到对应的物理内存单元
>
> > * 优点：对编译器的地址管理比较友好
> > * 缺点：没有解决数据连续存储内存利用率低的问题，因为一个段管理了很多变量数据，这些变量就都从同一个起始位置进行偏移，也就在物理地址中使用了连续的地址空间（分段号式管理中，同一个段内数据都使用了连续的地址空间）每个段之间不用连续，但是段内是连续的
>
> 

2.分页式

![image-20220113191332792](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220113191332792.png)

> 因为通常物理块比较小，并且不要求同一个进程的多个数据必须在同一块内，因此分页式实现了数据在物理内存中的离散式存储，提高了内存利用率
>
> 并且页表会在进行内存访问的时候进行内存访问控制（是否有权限）
>
> * 页表放的是页表项，每个页表项保存的都是一个虚拟内存页与对应物理内存块的映射关系
>
> * 分页式管理的优点：
>
>   >  实现数据离散式存储，提高内存利用率，并且通过页表进行内存访问控制

分页式与分段式各有优缺点，所以我们用段页式

![image-20220113191124328](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220113191124328.png)

在32为系统中，若页表大小是4096，则页表项有1024*1024个，也就是2^20

虚拟地址中页号占据虚拟地址的高20 位

3.段页式

> 综合了 分段式 和分页式，将内存进行分段，在每个段内采用分页管理







###  缺页中断

页表中有一个中断位---缺页中断，表示当前的虚拟地址要找的数据是否在物理内存中，（如果没在就会发生缺页中断

一个进程怎么会没在内存中呢？

内存管理

磁盘在分区的时候，至少有两个分区--

1.交换分区---用于内存不够时，将内存中的某些数据腾出来放到交换分区，腾出空间给紧急的数据处理，等到使用数据出发缺页中断的时候在交换回来

2、文件按系统分区---用于文件数据存储



到底应该将哪些数据放到磁盘上呢---内存置换法：最久未使用，最少未使用

## 进程控制

###  进程创建

### pid_t fork(void);

> 代码共享，数据独有![image-20220113193457566](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220113193457566.png)

内存管理的过程

子进程复制父进程，复制了pcb，页表，虚拟地址空间，所以一开始父进程处理个数据（标识符）之外都是一样的，并且父子进程的数据指向同一块物理内存，所以看起来父进程有什么，子进程也有什么

但是进程之间要保持独立性，数据独有，各有各的数据，因此当某一块空间的数据将要发生改变，则为子进程重新开辟物理内存，将数据拷贝过去

为什么不一开始就给子进程开辟空间呢？

> 如果这个子进程不适用，不就浪费了嘛，降低了进程创建的效率，还会造成内存冗余数据

所以我们采用写时拷贝技术

> 写时拷贝技术---为了提高子进程创建效率，毕竟有些数据从来不会改变，比如代码，重新开辟一块数据拷贝过去，没有意义，反而占据更多的内存

可以做到

> 进程拥有独立性，各有各的虚拟地址空间，映射各自数据存储
>
> 进程之间没有交叉关系，不会受到其他进程的影响，为了保证进程的稳定运行

返回值：对于父进程返回的是子进程的pid，是大于0的

​                对于子进程返回的是0

通过返回值可以进行父子代码分流

pid_t pid = fork();

if(pid < 0)  error

if(pid > 0) parent

if(pid == 0) child

![image-20220114083300978](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220114083300978.png)

###  pid_t vfork()

创建一个子进程，但是一个父进程使用vfork创建子进程之后，vfork的调用并不会立即返回（通常说会阻塞父进程），而是让子进程先运行，直到子进程退出，或者程序替换之后，父进程才能运行



vfork创建子进程有一个特殊的地方，**父子进程共用了父进程的虚拟空间**，所以子进程数据改变，父进程数据也会改变，在程序运行中，每调用一次函数，就会有一次函数压栈，函数调用栈

因为父子进程公用虚拟地址空间，使用了同一个栈，则若父子进程同时运行，就会造成调用栈混乱，让子进程先运行，直到子进程退出或者程序替换后有了自己的地址空间（在原有的地址空间中子进程的调用就都出栈了）

但是要注意，vfork创建的子进程，不能在main()函数中使用return退出，因为子进程使用return退出的时候释放了所有资源，父进程运行的时候资源是错误的











### 进程终止

方法一：

main函数中的return

![image-20220114084028840](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220114084028840.png)

![image-20220114083925610](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220114083925610.png)

---



![image-20220114084734592](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220114084734592.png)



![image-20220114084703376](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220114084703376.png)

方法二

> #include <stdlib.h>
>
> 在任意一个位置调用void exit(int status),可以在程序的任意一个位置退出一个进程



![image-20220114084947540](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220114084947540.png)

![image-20220114084914876](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220114084914876.png)



方法三

> #include <unistd.h>
>
> 在任意一个位置调用void _exit(int status),可以在程序的任意一个位置退出一个进程



![image-20220114085416985](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220114085416985.png)

![image-20220114085337481](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220114085337481.png)



看起来exit和_exit没什么不同呀

exit和_exit的区别

> 1.exit是库函数，_exit是系统调用接口
>
> 2.exit退出程序时，会刷新缓冲区，将缓冲区数据写入文件，_exit退出程序时，直接释放资源，不会刷新缓冲区



printf打印数据，实际上是把数据交给显示器，让显示器显示出来，涉及到了不同设备之间的数据交互

如果有很多小的数据要频繁交给显示器，效率是比较低的

因此操作系统做了一种优化

把很多小数据放到内存缓冲区中，积累成一个大的数据，然后让显示器一次性取出来，只有一次设备间的交互

因此printf没有立即把数据交给显示器，而是放到内存中（缓冲区），等到程序退出的时候，或者缓冲区刷新的时候才会把数据交给显示器

\n的作用

> 1.换行
>
> 2.刷新缓冲区（特定的显示器设备，通常称之为标准输出）



### 进程等待

#### 进程退出的场景

正常退出：完成任务，按照逻辑运行到return或者exit地方退出了

异常退出：没有完成任务，程序运行到半途因为某些原因崩溃退出

> 不管子进程时正常退出，还是异常退出，只要每被处理，就会产生僵尸进程

父进程等待子进程，为了获取退出子进程返回值，释放退出子进程所有资源，避免产生僵尸进程

僵尸进程产生的原因：因为子进程先于父进程退出，为了保存退出的返回值，而无法完全释放资源产生的

#### 如何等待

##### 方法一

int wait(int *status);

处理退出的子进程，那么如果调用这个接口的时候没有子进程已经退出，则会使父进程等待，直到有子进程退出

返回值：

> 成功返回处理的退出子进程的pid,失败则返回-1（比如没有子进程）

阻塞：为了完成一个功能，我们发起一个调用，但是若当前不具备完成功能的条件，则调用等待

非阻塞：为了完成一个功能，我们发起一个调用，但是若当前不具备完成功能的条件，则调用立即报错返回

status输出型参数，用于获取退出子进程的返回值

不等待的情况

![image-20220114103259475](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220114103259475.png)



![image-20220114104542851](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220114104542851.png)



等待的情况

记得包含头文件#include <sys/wait.h>



![image-20220114103908521](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220114103908521.png)

![image-20220114103817402](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220114103817402.png)

##### 方法二

int waitpid(int pid, int *status, int option);

也是处理退出的子进程，但是与wait不同之处

> 1.wait等待的是任意一个子进程的退出（wait是一个父进程假设有很多子进程，任意一个退出，都会处理后调用返回
>
> waitpid可以等待指定的子进程，也可以等待任意一个子进程，通过第一个参数确定（第一个参数pid==-1则表示等待任意子进程
>
> 2.wait是一个阻塞接口（wait如果没有子进程退出，则会一直等待）
>
> waitpid可以默认阻塞，也可以设置为非阻塞，通过第三个参数确定（第三个参数option==0表示默认阻塞；option==WNOHANG则表示非阻塞）

这是只判断了一次，但是如果正好错过，就不能避免僵尸进程，所以需要循环判断

![image-20220115000039257](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220115000039257.png)







![image-20220115000001347](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220115000001347.png)



![image-20220115000151311](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220115000151311.png)



需要循环判断

![image-20220115000827431](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220115000827431.png)



![image-20220115000740210](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220115000740210.png)

![image-20220115001023995](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220115001023995.png)





返回值

> 成功则返回退出子进程的pid大于0，若没有子进程退出返回0，若出错则返回-1



==非阻塞操作，通常需要循环处理，否则一次处理不成功，总不能不处理，得循环判断能否进行处理，直到成功==

两个接口的区别，在合适的地方使用合适的接口（比如 不想一直等待子进程退出，则使用非阻塞）

> 注意通过wait接口获取的子进程退出的返回值，返回值只使用了一个字节进行保存，并且在返回的时候，并没有存储在status的低位

一个进程退出的场景只有两个：正常退出，一茶馆退出，一个进程只有在正常退出的时候，返回值才是有意义的，若进程异常退出，返回值没有意义

因此在获取返回值之前，先通过低七位判断进程是否正常退出，（若正常退出，则异常退出信号值为0，若异常退出，异常退出信号值大于0）

进程怎么直到自己异常了？

> 一个进程是否产生了异常，是操作系统检测到的，通知的进程，而信号就是进程中的异常通知的值，不同的值表示不同的异常

前面我们知道返回值被存在了低16 位中的高八位，那如何得到正确的返回值呢

> 1.首先先判断返回值是否有意义，因为异常退出的返回值是没有意义的，页没必要求取返回值
>
> 如何取出低7位
>
> 判断方法：status & 0x7f == 0就能判断一个进程是正常退出
>
> 如何取出低16位中的高8位？
>
> （status >> 8)&0xff
>
> 》 因为返回值只用了一个字节保存，因此进程的返回值最好不要大于255
>
> 



获取进程返回值的两种方法

1.

![image-20220115093852082](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220115093852082.png)



![image-20220115093947455](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220115093947455.png)





方法二

> 利用man waitpid查看手册

![image-20220115095613213](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220115095613213.png)





![image-20220115095033290](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220115095033290.png)

![image-20220115094856644](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220115094856644.png)



额外介绍：系统调用接口出错后，如何获取错误原因

> #include <errno.h>
>
> #include <string.h>
>
> char *strerror(errno);根据错误编号获取文字信息，错误都是上一次系统调用接口使用错误的原因
>
> perror(char *msg);直接打印上一次系统调用接口使用错误的原因



![image-20220115110424825](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220115110424825.png)

#### 程序替换

1.原理：

​	进程程序替换将当前进程的数据段和代码段进行替换，替换称为其他程序的数据段和代码段，并且更新堆栈信息

​	看到的现象：1

exec函数簇：

l:说明当前函数是 可变参数列表的函数

​			1如果函数名称当中带有p:则表示会去搜索环境变量PATH来查找待替换的程序

​           2如果函数名称当中不带有p:则表示不会去搜索环境变量，需要程序员自己指定待替换的程序的路径

​           3如果函数名称中带有e:表示程序员需要自己组织环境变量

v:说明当前函数是以字符指针数组的方式来进行传递参数的

​				1如果函数名称当中带有p:则表示会去搜索环境变量PATH来查找待替换的程序

​           2如果函数名称当中不带有p:则表示不会去搜索环境变量，需要程序员自己指定待替换的程序的路径

​           3如果函数名称中带有e:表示程序员需要自己组织环境变量

![image-20220115113935576](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220115113935576.png)





![image-20220115121938846](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220115121938846.png)

###  minshell

shell是命令行解释器的统称

当前使用的shell的名字是bash

bash其实也是一个程序





### 基础IO

### C语言操作文件接口

1.打开

> FILE *fopen(const char *path, const char *mode)
>
> path :打开文件的方式（文件路径+文件名称）
>
> mode： 以何种方式打开
>
> r:以只读方式打开，当文件不存在，就打开失败
>
> r+：以读写方式打开，当文件不存在时，就会打开失败
>
> w:以只写方式打开，如果文件不存在，则创建文件，如果文件存在，则会截断（清空）文件
>
> w+： 以读写方式打开，如果文件不存在，则创建文件，如果文件存在，则会截断（清空）文件
>
> a:以追加方式打开，只支持写，如果文件不存在，则创建文件，当前的文件流指针指向文件的末尾
>
> a+：以追加方式打开，支持读和写，如果文件不存在，则创建文件，当前的文件流指向了文件的末尾

返回值：打开成功返回文件流指针，打开失败返回null

2.写

fwrite

> size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);
>
> ptr: 要往文件中写的内容
>
> size: 要写入块的大小,,单位是字节
>
> nmenb: 块的个数，单位是个
>
> 写入的字节数量=size*nmemb
>
> **一般在程序中使用的时候，讲size设置为1，nmemb就表示写入发字节数量
>
> stream：文件流指针
>
> 返回值：返回写成功的块的个数

3.读

>  size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
>
> pre:将要读入的内容保存在哪里
>
> size: 每次读块的大小
>
> nmemb：块的个数
>
> stream:文件流指针
>
> 返回值：成功读到的块的个数

4.偏移

>  int fseek(FILE *stream, long offset, int whence);
>
> stream：文件流指针
>
> offset: 偏移量
>
> whence:
>
> ​				SEEK_SET
>
> ​				SEEK_CUR
>
> ​				SEEK_END

5.关闭

>  int fclose(FILE *fp);
>
> 关闭文件流指针

**以上全部叫库函数**

### 系统调用函数的操作文件接口

1.打开

> open 
>
>   int open(const char *pathname, int flags, mode_t mode);
>
> pathname : 要打开的文件名称（路径+名称）
>
> flags： 以何种方式打开
>
> ​		必须的宏，三个，但只能出现一个
>
> ​			O_RDONLY：只读方式
>
> ​			O_WRONLY：只写方式
>
> ​			O_RDWR：读写方式
>
> ​		可选的宏
>
> ​    		O_APPEND:追加
>
> ​			O_TRUNC:截断
>
> ​			O_CREAT：文件不存在创建
>
> ​		使用方式，必须的宏和可选的宏之间使用按位或（eg:O_RDWR | O_CREAT)
>
> mode:权限
>
> ​		新创建出来的文件设置权限
>
> ​		传参的时候，传递八进制数字就可以
>
> 返回值：
>
> ​		打开成功，返回大于等于0的数字，是文件描述符
>
> ​		打开失败，返回-1

2.写

> ssize_t write(int fd, const void *buf, size_t count);
>
> fd: 文件描述符，open的返回值
>
> buf: 往文件里写的内容
>
> count: 写的内容的大小
>
> 返回值：写成功发字节数量



3.读

> ssize_t read(int fd, void *buf, size_t count);
>
> fd: 文件描述符，open的返回值
>
> buf: 将要读到的内容放到那里去
>
> count:最大可以读多少个，单位字节
>
> 返回值：返回读到的字节数量

4.偏移

> off_t lseek(int fd, off_t offset, int whence);
>
> fd:文件描述符
>
> offset:偏移量
>
> whence:
>
> ​		SEEK_SET
>
> ​		SEEK_CUR
>
> ​		SEEK_END

5.关闭

> int close(int fd);
>
> ​	关闭文件描述符

### 文件描述符

1.操作系统会为每一个进程在磁盘当中创建一个以进程号命名的文件夹，在该文件夹下有一个fd文件夹，保存的信息为该进程打开的文件描述信息

2.当我们新创建出来一个进程，势必会打开3个文件描述符，分别对应标准输入（0），标准输出（1），标准错误（2）

文件描述符其实就是内核当中的fd_array数组下标

文件描述符是一个正整数，分配原则为最小未占用原则

### 文件描述符（文件句柄）泄漏

当我们打开一个文件，，操作系统就会给程序分配一个文件描述符，如果在使用完毕后，没有及时关闭文件，则就会造成文件句柄泄漏

面试题：一个进程当中打开的文件数量最大是多少

命令一：ulimit -a

找到open files ----> (-n) 1024:表示最大能打开1024，但是这个不是硬性不可变的，通过ulimit -n [num]可以修改这个数量，num就是我们可以自己设定的值 

### 文件描述符 & 文件流指针的区别

1.文件流指针是fopen函数返回的，文件流指针是属于C库函数维护的

2.文件描述符是open函数返回的，文件描述赋予是内核在维护的

> typedef struct _IO_FILE FILE;

1.不同的文件流指针，在C库的当中会创建不同的struct _ IO_FILE,在_IO_FILE结构体中保存了不同的文件描述符

2.文件流指针当中包含文件描述符

3.操作系统当中广泛存在缓冲区，但是如果针对文件流指针而言的缓冲区，是c库在维护的

​		exit函数在退出的时候，会刷新缓冲区，就是因为操作的是文件流指针

​		_exit函数在退出一个进程的时候，不会刷新该缓冲区，是因为该缓冲区是C库在维护的，内核并不知道，所以不会刷新

### 重定向

1.清空重定向">",将文件里清空，在重定向数据进去

2.追加重定向">>",不清空文件里内容，在原有数据后在加上重定向内容，会换行

![image-20220120142340565](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220120142340565.png)

### 静态库 & 动态库

命令1：ldd [可执行程序]：查看当前按进程依赖的动态库文件

C动态库：libc so.6===>

![image-20220121154225732](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220121154225732.png)

命令2：file [可执行程序]：可以查看文件的属性

### 1.动态库

####   1.1生成

gcc/g++

-shared -fPIC

-o后面生成动态库的名字

​	前缀:lib

​	后缀：.so

​	libaba.so---> abab称为动态库的名字

#### 1.2使用

1.编译动态库的源码当中不能出现main函数

2.gcc -share -fPIC test.c -o libfunc.so

```c++
test.h
   void func();
test.c 
	func()
	{
		XXX;
	}
main.c
	#include "test.h"
	func();
```

编译执行的时候，要告诉编译器，我们链接的动态库是哪个：gcc main.c -o main -L [PATH]

指定连接动态库的名字：-l[库的名字（去掉前缀和后缀]

###  静态库

win下的静态库的后缀为.lib

win下的动态库的后缀为.dll

####  1.1生成

前缀：lib

后缀：.a

libabab.a---->abab就是静态库的名字

ar -rc lib[名字].a [依赖的文件]

**依赖的不是源文件，而是.o文件**

####  1.2使用

main.c

func()--->libfunc.a

gcc main.c -o main -L [path] -l[静态库的名字]

![image-20220121185921864](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220121185921864.png)

### 进程间通信

📍为什么需要进程间通信

​	原因是由于进程都拥有自己独立的进程虚拟地址空间，从而导致了进程的独立性，可以让不同的进程进行协作，

📍目前最大的进程间通信技术是：网络

#### 1管道啊

1.1从命令来看

​	ps aux | grep xxx

”|“就是管道

* ps命令和grep命令，他们是命令，同时也是程序
* ps aux的输出结果，通过管道，传输给了grep程序，换一句话说，ps aux的结果作为grep程序的输出

1.2管道就是在内核当中开辟的一块内存，也可以称之为内核缓冲区

管道分为两类

1.匿名管道

> 1.1在内核当中创建出来的一块内存是没有标识符的
>
>1.2如何创建一个管道
>
>​	int pipe(int fd[2]);
>
>​		fd[2]:整型数组，有两个元素，fd[0],fd[1]
>
>​		fd是一个出参
>
>​		fd[0]是读端
>
>​		fd[1]是写端
>
>数据流向只能从写端到读端
>
>​			输出型参数：参数在函数内部赋值，在函数外部使用
>
>​			输入型参数：参数在函数内部使用
>
>​			输入输出型参数：参数在函数内部使用，在函数外部使用
>
>返回值：成功返回0，失败返回-1
>
>管道是单双工通信，数据流只能从写端流向读端
>
>管道提供流式服务：读端可以决定每次读多少个字节
>
>管道的声明周期跟随进程
>
>![image-20220122180948052](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220122180948052.png)
>
>匿名管道只支持具有亲缘关系的进程之间的通信
>
>先创建管道再fork（）子进程，因为子进程要把文件描述符也拷贝进来

管道到底能够存储多大的数据

> pipe_size:64k
>
> pipe_buf:4k
>
> 进程操作写端往匿名管道当中写的时候，如果字节数量小于4k，则保证当前写入操作的原子性

管道对用的读写端文件描述符设置成为非阻塞属性

> 文件描述符的非阻塞属性：O_NONBLOCK
>
> int flag = fcntl(fd, F_GETFL);
>
> fcntl(fd, F_SETFL, flag | O_NONBLOCK)

2.命名管道

> 1.命名管道也是在内核当中开辟一段缓冲区，这段缓冲区是有标识符的，意味着：不同的进程，不需要有亲缘关系，只需要通过标识符就能找到该缓冲区
>
> 2.命名管道的创建
>
> ​	2.1命令创建
>
> mkfifo [命名管道文件]
>
> prw-rw-r--. 1 limengru limengru 0 Jan 22 23:07 fifo
>
> `p`代表管道文件,`-`代表普通文件
>
> ​	2.2函数创建
>
> mkfifo函数
>
> 3.特性
>
> ​	1.命名管道的声明周期也是跟随进程的
>
> ​	2.命名管道是具有标识符的
>
> ​	3.其他的特性和命名管道一致

#### 2.共享内存

> ![image-20220123190412651](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220123190412651.png)
>
> ###### 1.创建共享内存
>
> ​	int shmget(key_t key, size_t size, int shmflg);
>
> ​		key：共享内存标识符，这个标识符相当于共享内存的身份证
>
> ​				程序员在第一次创建的时候，可以任意给值，只要和当前操作系统当中的其他的共享内存标识符不重复；eg:0x99999999  0x88888888  0x12345678
>
> ​		size:共享内存的大小，单位字节
>
> ​		shmflg:
>
> ​				IPC_CREAT:如果共享内存不存在，则创建共享内存
>
> ​				IPC_EXCL:需要搭配IPC_CREAT一起使用，这样的宏在搭建使用的时候，，还是采用按位或的方式（核心思想就是位图） eg：IPC_CREAT | IPC_EXCL:如果想要获取的共享内存已经存在，则报错；如果想要获取的共享内存是刚刚创建出来的共享内存，返回操作句柄
>
> **总结**：使用shmget这个函数的时候一定要注意，是刚刚创建出来的共享内存
>
> 返回值：返回值是返回共享内存的操作句柄
>
> **共享内存的标识符和共享内存的操作句柄的区别**
>
> 标识符：是用来描述共享内存的，相当于共享内存的身份证，意味着不同的进程可以通过标识符找到这个共享你存
>
> 操作句柄：进程可以通过操作句柄来对共享内存进行操作（附加，分离，删除）
>
> ![image-20220127210346449](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220127210346449.png)
>
> 结论：共享内存的生命周期是跟随操作系统内核的
>
> ###### 2.将共享内存附加到进程
>
> void *shmat(int shmid, const void *shmaddr, int shmflg);
>
> ​	shmid:共享内存的操作句柄
>
> ​	shmaddr:附加到共享内存的虚拟地址，允许传递NULL值，让操作系统帮我们选择附加到共享区当中的那个地址，这个地址通过该函数的返回值返回给我们
>
> ​	shmflg:
>
> ​		SHM_RDONLY:规定当前进程只能对共享内存的进行读操作
>
> ​		0：可读可写
>
> ​	返回值：返回共享内存附加到共享区的地址
>
> **总结**：进程在读取共享内存的时候，是访问，不是拿走
>
> ###### 3.将共享内存和进程分离
>
> int shmdt(const void *shmaddr);
>
> ​	shmaddr:shmat的返回值
>
> ###### 4.操作共享内存
>
> int shmctl(int shmid, int cmd, struct shmid_ds *buf);
>
> ​	shmid:共享操作句柄
>
> ​	cmd:告诉shmctl函数需要做什么操作
>
> ​			IPC_STAT: 获取当前共享内存的属性信息，放在buf当中，buf是出参
>
> ​			IPC_SET:设置共享内存的属性信息，是用buf来进行设置的， BUF是入参
>
> ​			IPC_RMID：删除共享内存，buf可以直接传递为NULL
>
> ​	buf:共享内存的结构体
>
> ###### 5.删除共享内存
>
> 1.当使用shmctl或者使用ipcrm，删除共享内存之后，共享内存就实际被释放了
>
> 2.当共享内存被释放之后，共享内存的标识符就会被设置成0x00000000,表示其他进程不能通过之前的标识符找到该共享内存，并且共享内存的状态就会被设置为dest(destory)
>
> > 当共享内存被释放掉之后，但是还是有进程附加在共享内存，当前描述共享内存的结构体并没有被释放，直到当前共享内存的附加进程数量为0的时候才会被释放掉







#### 3 消息队列

1.队列都是先进先出，消息队列也满足先进先出的特性，内核当中实现消息队列的时候，是采用链表这个结构体

2.消息队列当中元素是有类型的，每一种类型是有优先级概念的

![image-20220127220953906](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220127220953906.png)

![image-20220127220743205](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220127220743205.png)

#### 4信号量

1.信号量的底层是一个计数器

2.信号量是用来进程控制的

临界资源：多个进程能够访问到的资源，被称为临界资源

​					多线程当中，多个线程都能访问到的资源，被称为临界资源

**面试题**

> 列举你所直到的进程间的通信：管道，共享内存， 消息队列，信号，网络，unix域套接字，信号量



### 进程信号

##### 信号的概念

> 1.信号是一个软件中断
>
> 2.信号的种类
>
> ​	1-31：非可靠信号，信号可能会丢失
>
> ​	34-64：可靠信号，信号是不可能丢失的
>
> 

##### 信号的产生

> 3.信号的产生
>
> 3.1硬件产生
>
> ​		ctrl+c:SIGINT(2)，是控制前台进程的
>
> ​			如何把一个进程放到后台运行，在启动命令之后加&符号
>
> ​			fg:就将刚刚放到后台的进程，放到前台来运行
>
> ​		ctrl+z:SIGTSTP(20)
>
> ​		ctrl+|:SIGQUIT(3):产生核心转储文件
>
> `gdb [可执行程序名称] [coredump文件]`
>
> ​		1.产生核心转储文件的条件
>
> ​				a.当前的操作系统当中一定不要限制coredump文件的大小 ulimit -a----->core file size
>
>    			 b.磁盘空间
>
> ​		2.
>
> ​			2.1解引用了空指针，进程就会收到11号信号（SIGSEGV），导致进程coredump
>
> ​			2.2内存访问越界，一旦进程崩溃，进程就会收到11号信号，也就会理论上产生coredump文件
>
> ​			2.3double free
>
> ​				进程会收到6号信号(SIGABRT)，导致当前的进程退出，并产生coredump
>
> free(NULL)会不会崩溃---不会崩溃
>
> 3.2软件产生
>
> ​		kill函数
>
> ​           int kill(pid_t pid, int sig)
>
> ​			pid:要给哪一个进程发送信号
>
> ​			sig:要发送的具体信号值
>
> ​		kill命令
>
> ​		abort函数：谁调用该函数，谁收到6号进程
>
> ​			封装了kill,kill(gitpid(),6);

##### 信号的注册

> 一个位图+一个sigqueu队列
>
> sig数组不是按照long类型来使用的，而是按照bit位来只用的，当前操作系统没有0号信号
>
> 每个信号在该位图当中都存在着一个与之对应的比特位
>
> 当与之对应的比特位为1的时候，表示当前进程收到了该信号
>
> ![image-20220127221817889](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220127221817889.png)
>
> 1.非可靠信号的注册
>
> ​	1.1当进程收到一个非可靠信号
>
> ​		第一件事情：将非可靠信号对应的比特位更改为1；
>
> ​		第二件事情：添加sigqueue结点到sigqueue队列当中去
>
> > 但是在添加sigqueue节点的时候，队列当中已经有了该信号的sigqueue节点，则不添加
>
> ![image-20220127222156020](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220127222156020.png)
>
> 2.可靠信号的注册
>
> ​	1.如果一个进程收到一个可靠信号
>
>   * 第一件事：在sig位图当中更改该信号对应的比特位为1
>   * 第二件事：不论之前在sigqueue队列当中是否存在该信号的sigqueue节点，都再次添加sigqueue节点到sigqueue队列当中去
>
> ![image-20220127222827376](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220127222827376.png)

##### 内核的源码

> ![image-20220127190224054](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220127190224054.png)

##### 信号的注销

> 1.非可靠信号的注销
>
> ​	1.将该信号的sigqueue节点从sigqueue队列中进行出队操作
>
> ​	2.信号在sig位图当中对应的比特位从1置0；
>
> 2.可靠信号的注销
>
> ​	1.将该信号的sigqueue节点从sigqueue队列当中进行出队操作
>
> ​	2.需要在判断sigqueue队列当中是否还有相同的sigqueue节点
>
> ​		2.1没有
>
> ​				信号在sig位图当中对应的比特位从1置为0
>
> ​		2.2还有
>
> ​				不会更改sig位图当中对应的比特位从1置为0

##### 信号的捕捉处理

> 1.SIG_DFL:默认处理方式
>
> 2.SIG_IGN:忽略处理
>
> ​	SIGCHLD信号
>
> 3.自定义信号处理方式
>
> ​		signal函数
>
> ​		typedef void (*sighandler_t)(int);
>
> ​		sighandler_t signal(int signum, sighandler_t handler);该函数可以更改掉信号的处理动作
>
> ![image-20220127223917754](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220127223917754.png)

##### 自定义信号处理函数

>sigaction函数
>
>int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
>
>​	1.signum:待更改的信号的值
>
>​	2.struct sigaction
>
>​		struct sigaction{
>
>​				void (*sa_handler)(int);➡函数指针，保存了内核对信号的处理方式
>
>​				void (*sa_sigaction)(int , siginfo_t *, void *);
>
>​				sigset_t sa_mask;➡保存的是当前进程在处理信号的时候收到的信号
>
>​				int  sa_flags;➡SA_SIGNFO，操作系统在处理信号的时候，调用的就是sa_sigaction函数指针当中保存的值
>
>​											0，在处理信号的时候，调用sa_handler保存的函数
>
>​				void (*sa_restorer)(void)➡预留信息
>
>}
>
>​	3.act:将信号处理函数变为act;
>
>​	4.oldact:信号之前的处理方式
>
>*int sigemptyset(sigset_t *set)➡将位图的所有比特位设置为0
>
>![image-20220128084756889](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220128084756889.png)
>
>什么时候进入内核空间：调用系统调用函数的时候，或者调用库函数的时候（库函数底层大多数都是封装系统调用函数的）

##### 信号阻塞

>![image-20220128085131526](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220128085131526.png)
>
>1.信号的阻塞，并不会干扰信号的注册
>
>​	信号该注册还是注册，只不过是当前的进程不能立即处理
>
>2
>
>​	2.1当我们将block位图当中对应的bite位置为1，表示当前进程阻塞该信号
>
>​	2.2当进程收到一个该信号的时候，进程还是一如既往的对该信号进行注册
>
>​	2.3当进程进入到内核空间，准备返回用户空间的时候，调用do_signal函数，不会立即处理信号了
>
>​	2.4这里的不会立即处理，不是之后不处理
>
>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
>
>​	how:告诉sigprocmask函数，应该怎么操作
>
>​	set:用来设置阻塞位图
>
>​		SIG_BLOCK:设置某个信号的阻塞
>
>​			block(new) = block(old) | set
>
>​		SIG_UNBLOCK:解除对某个信号的阻塞
>
>​			block(new) = block(old) & (~set)
>
>​		SIG_SETMASK:替换阻塞位图
>
>​			block(new) = set
>
>​	oldset:原来的阻塞位图

### 多线程

线程概念，线程控制，线程安全，互斥和同步，死锁，生产者与消费者模型，线程池



 1.线程概念

多线程如何                                                                                                    避免栈调用混乱

  

pid_t pid:轻量级进程id

pid_t tgid:轻量级进程组id



linux内核当中是没有线程概念的，而是轻量级进程的概念：LWP

通俗的线程概念其实是c库当中的概念，libc.so.6库中的



主线程：轻量级进程  struct task_struct{}

​	pid_t pid;

​	pid_t tgid

​	pid == tgid

工作线程

​	pid_t pid;

​	pid_t tgid;

​	pid一定是不一样的

​	tgid和主线程当中的tgid是一样的



线程的独有和共享

>共享：
>
>文件描述符表
>
>信号的处理方式
>
>当前的工作目录
>
>用户id 和组id





线程控制（线程创建，线程终止，线程等待，线程分离）

##### 1.线程创建

​	int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void * (*start_routine) (void *), void *arg);

​		pthread_t:线程标识符：是一个出参，出参的作用就是要出来起作用，在函数内部赋值，到外部出来起作用（线程标识符是保存的地址，线程号是线程的身份证）

​		pthread_attr_t：线程属性

​			栈的大小，大概是8M,但是可以修改，使用ulimit -s xxx

​			不设置线程属性，一般传值为NULL，采用默认属性

​		start_routine：本质是函数指针，保存线程入口函数的地址

​		arg:给线程入口的传参

返回值：成功：等于0

​				失败：小于0



> pstack [pid]:查看进程当中各个线程的执行调用堆栈
>
> top：
>
> ​	”1“：可以查看各个cpu的负载
>
> ​	top -H -p [pid]:查看各个线程的工作状态

线程入口函数可以传递什么参数

1.临时变量

> 临时变量的生命周期
>
> 临时变量的值的改变
>
> 传递临时变量有可能导致越界问题

**不推荐大家传递临时变量**

2.结构体对象

> 参考临时变量

3.结构体指针

4.this指针

##### 2.线程控制

##### 2.1线程终止

法1.从入口函数return返回，该线程就退出掉了

法2.void pthread_exit(void *retval);

​	retval:返回信息，可以给也可以不给，是返回给等待线程退出的执行流的（如果不给，则传递NULL)

法3.int  pthread_cancel (pthread_t  thread);

​	thread:线程标识符，调用该函数的执行流可以取消其他线程，但是需要知道其他线程的线程标识符，也可以执行流自己取消自己的，传入自己的线程标识符

> 如何获取自己的线程标识符：pthread_self()

注意：线程在创建的时候，属性当中默认是joinable属性（意味着线程退出的时候需要其他执行流来回收线程的资源)

##### 2.2线程等待

int pthread_join(pthread_t thread, void **retval);

​	thread：要等待的线程标识符

​	retval:

​		return : 接收入口函数的返回值

​		pthread_exit :接收pthread_exit函数的参数

​		pthread_cancel：void** 当中保存一个常数PTHREAD_CANCELED:

> PTHREAD_CANCELED:内核当中PTHREAD_CANCELED：#define PTHREAD_CANCELED (void*)(-1)

注意：调用该函数的执行流在等待线程退出的时候，该执行流是阻塞在pthread_join 函数当中的

##### 2.3线程分离

​	1.作用：改变线程的属性：将joinable属性改变成detach属性，当线程退出的时候，不需要其他线程来回收退出线程的资源，操作系统会默认回收

​	2.int pthread_detach(pthread_t thread);

​		thread:想要被分离线程的线程标识符

##### 3.线程安全

1.线程不安全的现象（抢票）

2.线程不安全的原理

>2.1结论：线程不安全会导致程序结果出现二义性
>
>2.2举例
>
>​		a.假设现在在同一个程序当中有两个线程，线程A和线程B（一个CPU），并且有一int 类型的全局变量，值为10，线程A和线程B在各自的入口函数当中都对这样一个全局变量，值为10，线程A和线程B各自的入口函数当中都对这个全局变量进行++操作
>
>​		b.线程a拥有CPU之后，对全局变量进行++操作，并非是原子操作，也就是说线程A在执行++的过程中可能会被打断，假设：线程A刚刚将全局变量的数值10读取到寄存器当中，就被切换出去了，，程序计数器当中保存下一条执行的指令，上下文信息当中保存寄存器的值，这两个东西是用来当线程A在次拥有CPU的时候，恢复现场使用的
>
>​		c.可能线程B拥有了CPU资源，对全局变量进行了++，并且将10加成了11，回写到内存当中
>
>​		d.线程A再次拥有CPU资源后，恢复现场，继续向下执行，从寄存器当中读到的值仍然是10，加完之后变成11，回写到内存当中也是11
>
>总结：理论上：线程A和线程各自对全局变量进行了+1操作，理论上全局变量的值应该是12，但是现在程序计算结果可能是11，所以这就是线程不安全
>
>

3.线程不安全的现象怎么解决

名词：

临界资源：多个执行流都能访问到的资源，就称之为临界资源

临界区：访问临界资源的代码块

怎么保证互斥：互斥锁

#### 互斥

1.想要保证互斥，我们需要用互斥锁

2.互斥锁本身也是一个资源，或者说我们也需要在代码当中来获取互斥锁，一定要只要多个线程想要保证互斥，需要都去获取互斥锁，否则就无法保证互斥

##### 互斥锁

1.本质：在互斥锁内部当中有一个计数器，其实就是互斥量

计数器的取值只能是0或1

> 1.当我们线程获取互斥锁的时候，如果计数器当中的值为0，表示当前线程获取不到互斥锁，也就是没有获取互斥锁，就不要再获取临界资源了
>
> 2.当线程获取互斥锁的时候，如果计数器当中的值是1，表示当前线程可以获取到互斥锁，也就是意味着可以访问临界资源，代码可以执行临界区当中的代码

2.计数器当中的值如何保证原子性

为什么计数器当中值从0变成1，或者从1变成0，是原子操作

![image-20220206210057511](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220206210057511.png)

获取锁资源的时候（加锁的时候）

1.寄存器当中的值直接赋值为0

2.寄存器当中的值和计数器当中的值进行交换

3.判断寄存器当中的值，得出加锁结果

![image-20220206210337362](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220206210337362.png)

当寄存器当中的值为1时，则表示可以加锁

当寄存器当中的值是0时，则表示不可以加锁



互斥锁的接口

​	1.初始化互斥锁变量

​		1.1动态初始化

​		pthread_mutex_t:互斥锁变量的类型

​		int pthread_mutex_init(pthread_mutex* mutex, pthread_mutexattr_t* attr)

​		pthread_mutex_init会初始化互斥锁变量

​			mutex:传入互斥锁变量的地址

​			attr:属性，一般传递NULL，采用默认属性

> 举例：pthread_mutex_t lock_;
>
> ​			pthread_mutex_init(&lock_, NULL);

​		1.2静态初始化

​		pthread_mutex_t lock_ = PTHREAD_MUTEX_INITIALIZER;

​		pthread_mutex_t ----->结构体

​		PTHREAD_MUTEX_INJITIALIZER 	宏定义了一个结构体的值

> #define PTHREAD_MUTEX_INJITIALIZER\{{0,0,0,0,0, _PTHREAD_SPINS,{0, 0}}}

​	2.加锁 -1

​		int pthread_mutex_lock(pthread_mutex_t *mutex):阻塞加锁的接口

​			mutex:传入互斥锁变量的地址

​			如果mutex当中的计数器的值为1，则pthread_mutex);ock接口就返回了，表示加锁成功，同时计数器当中的值会被更改为0

​			如果mutex当中的计数器的值0， 则pthread_mutex_lock接口就阻塞了，pthread_mutex_lock接口没有返回，阻塞在函数的内部，直到加锁成功

​	

​		int pthread_mutex_trylock(pthread_mutex_t *mutex);

​			1.该接口是非阻塞加锁接口

​			2.含义：2.1当互斥锁变量当中的计数器置为1，则加锁成功返回

​							2.2当互斥锁变量当中的计数器置为0，也会返回，但是一定要清楚，加锁并没有成功，也就是不要去访问临界资源

​							2.3一般我们非阻塞接口都需要搭配循环来使用

​			3.带有超时时间的加锁接口

​				int ptread_mutex_timedlock(pthread_mutex_t *mutex, const struct timespec * abs_timeout);

​				3.1带有超时时间的接口，也就是意味着当不能直接获取互斥锁的时候，会等待abs_timeout时间

​				如果在这个时间内加锁成功了，直接返回，不需要再继续等待剩余的时间

​				如果超过该事件，也返回掉了，但是表示加锁失败了，需要循环加锁

​	3.解锁 +1

​		int pthread_mutex_unlock(pthread_mutex_t* mutex)

​			1.不管是哪一个加锁接口加锁成功，都可以使用该接口进行解锁

​			2.解锁的时候，会将互斥锁变量当中的计数器的值，从0变成1，表示其他线程可以获取互斥锁

​	4.销毁互斥锁

​		针对的是动态初始化的互斥锁





> 黄牛的例子
>
> 1.在哪里初始化互斥锁
>
> 2.在哪里进行加锁
>
> ​	开始访问临界资源是时候就需要加锁
>
> 3.在哪里进行解锁
>
> ​	在所有可能导致线程退出的地方进行解锁，否则执行流有可能带着锁就退出了，其他执行流就拿不到锁了
>
> 4.在哪里释放互斥锁



#### 同步

1.同步是为了保证各个线程对临界资源访问的合理性

2.条件变量

​	本质：PCB等待队列+一堆接口（等待接口—+唤醒接口）

> 条件变量的接口
>
> 1.初始化
>
> ​	int pthread_cond_init(pthread_cond_t* cond, pthread_condattr_t* attr)
>
> ​		cond:pthread_cond_t:条件变量的类型，传参的时候还是传入条件变量的地址
>
> ​		attr:条件变量的属性，通常传递NULL，采用默认属性
>
> 2.等待 将调用该接口的线程放到pcb等待队列当中
>
> ​	int pthread_cond_wait(pthread_cond_t* cond, pthread_mutex_t* mutex);
>
> ​		cond:条件变量
>
> ​		mutex:互斥锁
>
> 3.唤醒
>
> ​	int pthread_cond_signal(pthread_cond_t* cond)
>
> ​		作用是：通知PCB等待队列当中的线程，将其从队列中拿出来，唤醒该线程
>
> ​		唤醒至少一PCB等待队列当中的线程
>
> ​	int pthread_cond_broadcast(pthread_cond_t*cond)
>
> ​		唤醒PCB等待队列当中全部的线程
>
> 4.释放
>
> ​	int pthread_cond_destroy(pthread_cond_t* cond)

pthread_cond_wait接口

> 1.为什么会有互斥锁
>
> ​	1.1同步并没有保证互斥，而保证互斥的是使用到了互斥锁
>
> ​	1.2pthread_cond_wait内部会进行解锁互斥锁
>
> ​          到底是先解锁，韩式先放到PCB等待队列中
>
> 》  一定是先放到PCB等待队列中，在进行解锁



pthread_cond_wait接口内部实现逻辑

> 2.1将调用pthread_cond_wait函数的执行流放到PCB等待队列中
>
> 2.2解互斥锁
>
> 2.3等待被唤醒
>
> ​	假设被唤醒后，应该如何做
>
> ​		1.从PCB等待队列当中移除出来
>
> ​		2.抢占互斥锁
>
> ​			情景1：拿到互斥锁，pthread_cond_wait函数就返回了
>
> ​			情景2：没有抢到互斥锁，阻塞在pthread_cond_wait函数内部的抢锁逻辑当中
>
> ​			一定要知道，当卡在pthread_cond_wait内部抢锁逻辑的执行流一旦时间片耗尽，意味着当前线程被切换出来，程序计数器当中保存的就是抢锁的指令，上下文信息当中保存的就是寄存器当中的值
>
> ​		当再次拥有CPU时间片之后，从程序金属漆和上下文信息当中恢复抢锁的逻辑
>
> ​			直到抢锁成功，pthread_cond_wait函数才返回



![image-20220207074609594](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220207074609594.png)



#### 死锁

1.当多个执行流使用同一个互斥锁的时候，有一个执行流获取到互斥锁之后，但是没有释放互斥锁，导致其他执行流都卡死在加锁的接口中，我们称之为这种现象是死锁

​	gdb:查看多线程的都调用堆栈，可以使用thread apply all bt

2.

![image-20220207075012547](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220207075012547.png)



多个执行流，多个互斥锁的情况下，每一个执行流都占用以吧互斥锁，但是还有申请对方互斥锁，这种情况下，就会导致各个指令流都阻塞掉，这种现象称之为死锁



```
thread apply all bt//查看多个线程堆栈
```





```
t [线程编号] //跳转到具体线程的堆栈当中，线程编号就是gdb调试的时候，看到的thread [num],num就是线程编号
```

![image-20220207080410470](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220207080410470.png)

死锁的四个必要条件

1.互斥条件

2.请求与保持条件，吃着碗里的看着锅里的

3.不可剥夺条件

4.循环等待



预防死锁的条件

1.破坏必要条件（只能破坏请求与保持和循环等待）

2.加锁顺序一致

3.不要忘记解锁，在所有可能导致执行流退出的地方，都进行解锁



### 生产者与消费者模型

123规则

1个线程安全的队列

队列的特性，先进先出，左右满足先进先出特性的结构体我们都可以称之为队列

​	线程安全：需要保证在同一时刻，队列当中的元素只有一个执行流去访问（互斥锁+条件变量）

2种角色的线程

生产线程和消费线程

3种关系

生产者和生产者互斥

消费者与消费者互斥

生产者与消费者同步+互斥



优点

> 支持忙闲不均
>
> 生产者与消费者解耦开来
>
> 支持高并发

![image-20220207085320038](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220207085320038.png)







posix版本的信号量

信号量

> 本质：计数器+PCB等待对列+一堆接口（等待接口，唤醒接口）
>
> ​	计数器：本质是对资源的计数
>
>   * 当执行流获取贤浩良成功之后，信号量当中的计数器会进行减一操作
>     		* 当获取失败之后，该执行流就会被放到PCB等待队列当中
> 		* 当执行流释放信号成功之后，信号量当中的计数器会进行加一操作

接口

> int sem_init(sem_t *sem, int pshared, unsigned int value);
>
> ​	sem:传入信号量的地址，sem_t 信号量的类型
>
> ​	pshared:该信号量是用于线程间还是用于进程间
>
> ​		0：用于线程间，全局变量
>
> ​		非0：用于进程间
>
> ​			将信号量的所用到资源在共享内存当中进行开辟
>
> ​	value:资源的个数，本质上是初始化信号量计数器的
>
> 信号量可以完成线程与线程之间的同步与互斥，也可以完成进程与进程之间的同步与互斥

互斥：

> 1.初始化信号量当中的计数器为1，表示说只有一个资源可以使用
>
> 2.当执行流A想要访问临界资源的时候，首先获取信号量，由于计数器当中的值为1，表示可以访问，计数器从1变成0，从而执行流A去访问临界资源
>
> 3.此时当执行流B想要访问临界资源的时候，获取信号量，但是计数器当中的值为0，表示不能够访问临界资源，执行流B的PCB就被放到了PCB等待队列当中，同时信号量当中的计数器的值减一，（0--->-1),-1表示当前还有一个执行流在等待访问临界资源

同步

> 1.不要求信号量当中的计数器一定为1，也可以为其他正整数
>
> 2.当执行流想要访问临界资源的时候，首先获取信号量
>
> ​	2.1如果信号量当中的计数器大于0，则表示能够访问临界资源，则该执行流不会阻塞，顺序执行临界区代码
>
> ​	2.2如果信号量当中的计数器值小于等于0，则表示不能访问临界资源，则该执行流会被放到PCB等待队列当中，同时计数器也会进行减一操作
>
> ​			注意：如果计数器的值为负数，表示当前还有计数器的绝对值个执行流在等待
>
> 3.当释放信号量到时候，会对信号量当中的计数器进行加一操作，是否唤醒PCB等待队列当中的执行流呢？
>
> ​	3.1计数器加一操作之后还为负数，或者为0， 则需要通知PCB等待队列当中的执行流
>
> ​	3.2计数器加一操作之后为正数，则不需要通知PCB等待队列

信号量版本的生产者与消费者







线程池









# 网络编程

##  1.网络初识

##  socket套接字

udp编程

tcp编程

tcp编码







![image-20220219143718200](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220219143718200.png)

第一件事，将字符串类型的ip地址，转换成了32位的无符号整形

第二件事，将主机的无符号32位整形，转换成了网络的









connect refuse解决办法

在客户端用curl探测端口，发现22端口正常，9999端口被拒绝。

判断22号端口没有问题

![image-20220219155523459](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220219155523459.png)





![image-20220219155630694](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220219155630694.png)

下面就是关闭防火墙

我的系统是，

centos7

首先查看防火墙是否运行

![image-20220219155747751](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220219155747751.png)



先切换到root下

![image-20220219160409103](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220219160409103.png)

![image-20220219160352192](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220219160352192.png)

前面的方法，一旦重启操作系统，防火墙就自动开启了，应该执行下面的命令来设置才能永久关闭防火墙呢？
输入命令：
systemctl disable firewalld.service，开机禁止防火墙服务器
systemctl enable firewalld.service，开机启动防火墙服务器







![image-20220219160606434](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220219160606434.png)





抓包

