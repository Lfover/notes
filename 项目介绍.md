项目介绍

我作的这个项目是一个模拟力扣的项目，这个项目一共实现了三个请求的处理以及响应，三个请求分别是两个get请求，和一个post请求，第一个get请求是获取题目列表，第二个get请求是获取题目列表基础上的点击链表当中的任意一个题目，获取题目的相关信息，实现方法是一样的，当你输入url之后，例如在请求题目列表这个get请求，Url输入到浏览器中的框，将这个请求转发到我的http服务器上，这是一个bs架构，通过浏览器可以访问我的项目，首先说明一点，所以题目都是以文件的方式进行组织，所有题目都是写到文件当中，以及测试用例，测试代码都是，所以使用了一个配置文件，这个文件包含了看题目路径，题目id等信息，通过配置文件可以寻找到所有题目，做一个统筹规划，

当我的服务器检测到一个get请求时，首先读取这个文件，获取到题目的一些信息。题目名字，题目标号，将题目的名字和编号，放在一个vector当中，将这个数组当中的题目名字和编号插入到一个数据字典当中。这个数组字典的作用就是将html文件当中预定义的模板进行填充，使用的时谷歌模板分离技术ctemplate框架,所有的框架都是预先定义好的，ctempalte中的dictionary将实现vector中的数组插入到模板中，并生成html文件，模板代码中只定义了一行模板，使用{}和#符号定义待填充的字符串，使用dictionary遍历我取出来的vector信息，经过渲染之后返回给客户端，所以说返回给浏览器的是html文件，这个文件是经过填充完整的文件，用户拿到这个文件，经过渲染之后就可以看到题目的列表，

点击它之后就可以发起项目的第二个请求，是获取题目信息，通过题目id来进行区分，当点击题目的名字，产生第二个get请求，它会将题目id发送到http服务器，同样的处理流程，在配置文件中找到题目ID，并且在配置文件中配置了题目路径，每个题目都是一个文件夹，编号命名文件，所以拿到编号就可以找到所在的路径，就可以将题目信息提取到一个map当中，然后将这个map通过数据字典 将预定义好的模板进行填充，然后将html文件按返回给用户浏览器，展示题目信息

第三个post请求，在用户请求成功后，给用户一个文本框，支持用户编写代码，然后点击提交，点击提交的一瞬间会产生一个post请求，将这个请求全部打包房子啊请求体中，将服务器检测到这个代码之后，首先将请求体当中的代码取出来，然后这一部分是用户编写的代码。与我预先定义好的头文件和预先定义好的测试文件这三个文件的拼接，拼接成一个完整的可编译的源代码，将源代码写入到一个tmp文件当中，这个文件的命名格式采用了三部分，

首先是题目的名称，题目的时间戳，时间戳是一个精确到毫秒的，第三个是automake变量，之所以使用三个部分来命名，是因为可能是同一个时间，同一个题目在不同时间做提交做一个区分，如果实在是同一个时间有很多个请求打到服务器上，就会产生若干个临时文件，同一个题目产生了若干个临时文件，就可能时间戳可能相等，因为时间只到毫秒，也有可能同一时间来了几百个文件，那时间戳就没有办法区分，所以使用了一个automake用了一个unsigned int这样一个类型就可以保证每一个文件的unordered int 的值是从0开始的这样对他做一个，因为automakr的值的增加的是一个加锁的，就是说，某一段时间内只有一个进程能够拿到这个变量，对他进行一个++操作，这样能够保证文件命名唯一的这样的方法，将用户的 代码和预先定义好的代码 三个合成一个可编译的代码放在这个文件当中，这个文件就是后序我进行编译运行的依据，我会根据这个文件名 来找到这个文件，对他进行一个编译，这个名字是一直传递下去的，

因此这个这个时候就会采用创建子进程方式去对这个代码进行编译，之所以使用创建子进程而不使用创建多线程的方式是 因为gcc本身就是一个程序当你使用你进程的情况下，才不会影响到你处理这个请求的进程不被替换，只有你创建子进程，并且主进程处于wait状态，这样让这个子进程去替换gcc程序，这样才不会影响到主进程的上下文，当进程进行替换并且执行编译的之后，将这个编译的结果重定向到一个文件当中，然后当着问文件中的结果编译成功，使用一个enum枚举了类型来表示在编译运行过程中发生了什么事情，作为一个运行结果，是编译失败了还是运行失败了，还是没有问题，这是编译阶段，我会将运行的结果重定向到一个文件当中，如果这一阶段没有问题的情况下，我才会创建子进程，子进程程序替换运行这个文件，因为上一阶段的编译结果一定是一个可运行的二进制文件，

如果他编译简短没问题则一定会产生一个可编译的二进制文件，这个文件的命名依旧采用之前的方式，编译与运行都是采用创建子进程，子进程程序替换的方式来做一个同步的运行，主进程处于一个等待的状态，在运行阶段做了一个限制，例如有些题目出现死循环和申请内存空间申请过大的情况，使用了rlimit结构体，主要使用了rlimit当中的一个soft limit 主要是一个对他软的限制，这样就能防止在运行的是有死循环或申请过多内存的情况 导致我的物理内存申请不够这样一个问题的杜绝，当着个结果运行出来以后，同样会对这个结构重定向到一个文件当中，最后对它做一个返回值的封装，用enum来判断运行阶段有没有出问题，如果出问题了就返回一个运行状态错误，如果运行都成功了就输出一系列的ok，因为测试用里就是使用将用户暑促的答案和测试用例的答案进行对比，字符串的对比，每一个测试案例的结果都相同话，表示用户的这个代码通过了，就给用户做一个反馈