# 文件压缩项目

## ZIP步骤

第一步：将源文件中重复出现的语句使用更短的长度距离对来进行替换---可以达到压缩的目的，使用LZ77的思想就可以将源文件中的重复语句消除

第二步：对于LZ77的结果还可以进行从字节层面的压缩，LZ77的结果可能再字节层面还有一定的重复

> 从字节层面进行压缩:给每个字节找一个更短的编码来进行替换
>
> 1.静态编码：根据源文件中字节的出现情况直接算出编码
>
> 2.动态编码：需要根据源文件中字节的出现情况来动态进行获取，压缩效果一般较好---》借助huffman树来获取每个字节的编码

##### huffman树压缩的思路

不论是什么样的文件，文件在磁盘中都是以字节形式存储的，所以huffman树压缩是一种通用的文件压缩

要将字符定义成无符号char类型

一个编码不能是另外一个编码的前缀

> 1.先统计源文件每一个字节出现的次数
>
> 字节总共又8个比特位，字节的不同种类总共有256个（2的8次方等于256）
>
> 2.使用CharInfo作为权值来创建huffman树，就是通过节点出现的个数来进行创建huffman树
>
> huffman树的常见规则（借助小堆（默认创建大堆）每次取两个堆顶元素创建小二叉树）==权值需要进行相加，还有进行节点大小的比较，因此需要重载">", " +"
>
> 过滤掉没有出现的字符，也就是没有出现的字符不用出现在huffman树中 ，即出现次数为0的字符
>
> 3.获取huffman编码， 树采用孩子双亲表示法，通过递归遍历二叉树，如果走到叶子节点，则判断是左孩子韩式右汉字，如果左孩子就代表0，右孩子代表1，最终将获得到的编码进行逆置

##### 开始压缩

在拿到编码以后，就将源文件按中的每一个字符按照编码的格式进行改写，记得将文件指针恢复到起始位置，不然读不到字符

遍历文件(1.txt)，找到一个字符对应的编码是什么（例如A:110)利用位运算进行填充字节，如果满了8字节，就将这个8比特位写入新的压缩文件（2.txt)

注意处理最后一个字节的特殊情况，因为最后一个字节可能没有满8个字节，最后将没有满8个比特位的左移缺少的位（8 - bitCount)就可以存入到文件中

但是解压缩时如何知道右几个比特位是无用的

> huffman树的根节点的大小就是总共的字节数

例如编码A：110， B：100， C：0

源文件：AABBC

11011010    01000

   A    A       B     B  C



##### 解压缩

条件：在压缩文件中必须保存压缩时用到的huffman树的信息， 因为要解压缩的时候也需要用到huffman树来找叶子节点，huffman树怎么保存

> huffman树时如何创建的，就将创建huffman树使用到的每个字节，以及字节出现的次数保存起来就可以了
>
> 所以一个解压缩文件中需要包含的内容有 
>
> 1.用来解压缩的信息（源文件后缀， 行数，《字符，个数》
>
> 2.源文件压缩之后的比特流数据

1.从压缩文件中逐个获取每个字节

2.逐个检测该字节中的每个比特位，来遍历huffman树

遍历到根节点就是找到了一个字符，将她写入文件

3.cur遇到0向左走，遇到1向右走,走到叶子节点就是解压缩出来了一个字符（注意处理最后一个不足8个比特位的）

![image-20220601170311073](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220601170311073.png)



如何判断 压缩和解压缩后的文件一模一样

![image-20220601213800102](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220601213800102.png)

大仙文件只压缩了一部分，是因为打开压缩文件的方式引起的 无论是源文件还是压缩文件都需要使用二进制来处理，因为如果遇到11111111，即ffff会被处理成-1，就当成文件末尾了，后面的数据就不会处理 了



> 在文本文件中，所有的有效数据都不会出现某个字节位-1的情况，而-1是作为文件结尾标记的
>
> 二进制格式的文件中数据可能会存在-1

为什么使用huffman树压缩的效率十分低

![image-20220601214350658](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220601214350658.png)

![image-20220601214544334](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220601214544334.png)

![image-20220601214626502](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220601214626502.png)

范式huffman树所有的孩子节点都在左侧

每层叶子节点按照从小到大进行排列

![image-20220601214847892](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220601214847892.png)

上一层编码  加上  上一层的个数， 然后再左移编码长度的差值

![image-20220601215407192](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220601215407192.png)

![image-20220601215425813](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220601215425813.png)





LZ77压缩

![image-20220602220135783](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220602220135783.png)

1.原理

将源文件中重复语句使用更短的长度距离来进行替换

存在问题

> 1.如何区分什么时候是源字符，什么时候是《长度距离》对
>
>  2.如何在前文找重复，如何找到最长的重复
>
> 3.重复几个字节才要替换 

2.条件

因为需要从文件中读出数据，才可以判断有无重复的字符，音系需要缓冲区，大小是64K

因为这个算法是77年提出来的，因此那个年代的内存比较小，可能只有几十兆的空间，基于考虑只给了64K，着64K中放的都是带压缩的数据

![image-20220602222731473](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220602222731473.png)

查找缓冲区逐渐变大，线性缓冲区逐渐变小，但是查找重复不可能永远都是找到最左端，那样消耗的时间太大，虽然向左找的越多可能匹配到重复的数量更多，但是采用局部性原理，只向左找到部分长度

> 距离最多使用15个比特位（32,768），实际上没有达到32K，而是WSIZE- MIN_LOOKAHEAD大小，临界点就是先行缓冲区中剩余的MIN_LOOKAHEAD大小，就将右窗中的数据搬移到左窗
>
> 长度用一个字节，如果超过一个字节就拆分成两个进行匹配
>
> 所以最少重复三个字节才会替换

![image-20220602231124956](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220602231124956.png)

问题2

1.暴力

2.哈希

三个字符一组，保存首字符的下标

哈希算法：2^15 = 32k, 2^24 = 32M

哈希的大小是

![image-20220602232902500](C:\Users\86134\AppData\Roaming\Typora\typora-user-images\image-20220602232902500.png)